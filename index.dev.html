<!DOCTYPE html>
<html lang="es">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D7CWN7QR83"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-D7CWN7QR83');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Fortaleza - Aventura de Texto (v1.43)</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        @font-face {
            font-family: 'IBM VGA';
            src: url('Flexi_IBM_VGA_True.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM VGA', 'Courier', monospace;
            background-color: #000;
            color: rgb(69, 191, 69);
            padding: 20px;
            line-height: 1.4;
            font-size: 160%;
        }

        #game-container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #000;
            xborder: 2px solid #0f0;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        #title {
            text-align: center;
            font-size: 34px;
            margin-bottom: 20px;
            color: #0f0;
            border-bottom: 2px solid #0f0;
            padding-bottom: 10px;
        }

        #output {
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            xborder: 1px solid #0f0;
        }

        #output::-webkit-scrollbar {
            width: 10px;
        }

        #output::-webkit-scrollbar-track {
            background: #000;
        }

        #output::-webkit-scrollbar-thumb {
            background: rgb(18, 51, 18);
        }

        .output-line {
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        /* Text scanline effect */
        .text-scanline {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 100%;
            background: rgba(57,255,20,.9);
            box-shadow:
                0 0 6px rgba(57,255,20,1),
                0 0 12px rgba(57,255,20,.7),
                0 0 18px rgba(57,255,20,.3);
            z-index: 5;
        }

        .text-scanline-dot {
            position: absolute;
            right: -3px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 4px;
            background: rgba(255,255,255,1);
            border-radius: 50%;
            box-shadow:
                0 0 8px rgba(57,255,20,1),
                0 0 16px rgba(57,255,20,.6),
                0 0 24px rgba(57,255,20,.3);
        }

        .text-reveal {
            position: relative;
            display: inline-block;
        }

        .text-mask {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 4;
        }

        #input-container {
            display: flex;
            gap: 10px;
        }

        #input {
            flex: 1;
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: 'IBM VGA', 'Courier', monospace;
            font-size: 14px;
        }

        #input:focus {
            outline: none;
            border-color: #0f0;
            xbox-shadow: 0 0 5px #0f0;
        }

        button {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'IBM VGA', 'Courier', monospace;
            font-size: 14px;
        }

        button:hover {
            background-color: #0f0;
            color: #000;
        }

        #fullscreen-btn {
            padding: 10px 15px;
            margin-left: 10px;
            font-size: 18px;
            line-height: 1;
        }

        #inventory {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #0f0;
        }

        #inventory h3 {
            margin-bottom: 10px;
        }

        .prompt {
            color: #ff0;
        }

        .error {
            color: rgb(255, 149, 0);
        }

        .success {
            margin-top: 30px;
            color: rgb(255, 204, 0);
        }

        .system {
            color: rgb(9, 255, 0);
        }

        /* ===== CRT look & feel (append at end) ===== */
        :root{
        --phosphor: #39ff14;                /* main glow color (set #ffb000 for amber) */
        --scanline-strength: .08;           /* 0â€“1  intensity of horizontal lines */
        --vignette-strength: .60;           /* 0â€“1  dark edges */
        }

        /* Subtle dark backdrop (optional) */
        body{
        background: radial-gradient(ellipse at center, #020402 0%, #000 90%);
        letter-spacing: .3px;
        position: relative;
        }

        /* Scanlines over the entire background */
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,.5) 0px,
                rgba(0,0,0,.5) 2px,
                transparent 2px,
                transparent 4px
            );
            opacity: var(--scanline-strength);
        }

        /* Make the screen a CRT with barrel distortion */
        #game-container{
        position: relative;
        overflow: hidden;
        border-radius: 16px;
        background: #000;
        box-shadow:
            inset 0 0 60px rgba(57,255,20,.06),
            inset 0 0 140px rgba(0,0,0,.9),
            0 0 0 1px rgba(57,255,20,.08);
        isolation: isolate;                 /* overlays stay inside */
        backface-visibility: hidden;
        }

        .crt-screen{
            position: relative;
            z-index: 0;
            backface-visibility: hidden;
            /* Barrel distortion with very smooth turbulence */
            filter: url(#crt-warp);
        }

        /* Static scanlines */
        /* Static scanlines (under everything else, but above content) */
            #game-container::before{
            content:"";
            position:absolute; inset:0;
            pointer-events:none;
            mix-blend-mode:overlay;
            border-radius:inherit;
            background:
                repeating-linear-gradient(
                0deg,
                rgba(0,0,0,.5) 0px,
                rgba(0,0,0,.5) 2px,
                transparent 2px,
                transparent 4px
                );
            opacity: var(--scanline-strength);
            z-index: 1;                  /* <-- ensure visible */
        }

        /* Vignette on top of *everything* */
        #game-container::after{
            content:"";
            position:absolute; inset:0; border-radius:inherit; pointer-events:none;
            background:
                radial-gradient(ellipse at center,
                rgba(0,0,0,0) 40%,
                rgba(0,0,0,var(--vignette-strength)) 100%),
                radial-gradient(ellipse at center,
                rgba(57,255,20,.12),
                rgba(0,0,0,0) 55%);
            mix-blend-mode:multiply;
            z-index: 4;                  /* <-- sits above all overlays */
        }


        /* Moving highlight bar */
        
        /* Moving highlight bar (between scanlines and vignette) */
        .crt-scanline{
        position: absolute;
        left: 0; right: 0;
        height: 4px;                  /* thickness */
        top: -6px;                    /* start just above the screen */
        background: linear-gradient(to bottom,
                    rgba(255,255,255,.45), rgba(255,255,255,0));
        mix-blend-mode: screen;
        opacity: .25;
        pointer-events: none;
        z-index: 2;                   /* under vignette, over scanlines */
        will-change: top;
        animation: crtScanTop 30s linear infinite;
        }

        @keyframes crtScanTop{
        0%   { top: -6px; }
        100% { top: calc(100% + 6px); }
        }

        /* Flicker overlay (above scan bar, under vignette) */
        .crt-flicker{
        position:absolute; inset:0;
        border-radius:inherit;
        pointer-events:none;
        mix-blend-mode:screen;
        z-index: 3;
        background: rgba(57,255,20,.06);      /* normal strength */
        animation: crtFlicker 1900ms steps(1000) infinite;
        }

        @keyframes crtFlicker{
        0% { opacity:.98 }
        50%{ opacity:1 }
        100%{ opacity:.99 }
        }

        .crt-scanline{ height: 18px; opacity: .02; animation-duration: 11s; }
        .crt-flicker{ background: rgba(57,255,20,.12); }

        /* Text glow / phosphor persistence */
        #title{
        letter-spacing:3px;
        text-shadow:
            0 0 0.6px var(--phosphor),
            0 0 6px rgba(57,255,20,.45),
            0 0 18px rgba(57,255,20,.15);
        border-bottom: 1px dashed rgba(57,255,20,.25);
        }
        #output{
        text-shadow:
            0 0 1px rgba(57,255,20,.8),
            0 0 6px rgba(57,255,20,.46),
            0 0 24px rgba(57,255,20,.35),
            1px 0 0 rgba(255,0,0,.135),       /* tiny chromatic bleed */
            -1px 0 0 rgba(0,255,255,.135);
        }

        /* Prompt feel for the input line */
        #input-container{
        position:relative;
        border-top: 1px dashed rgba(57,255,20,.25);
        padding-top:10px;
        display: flex;
        align-items: center;
        }
        #input-container::before{
        content:">";
        position:absolute;
        left:4px;
        color:var(--phosphor);
        text-shadow:
            0 0 0.6px var(--phosphor),
            0 0 6px rgba(57,255,20,.45);
        opacity:.9;
        animation:blink 1.2s steps(1) infinite;
        line-height: 1;
        }
        @keyframes blink{ 0%,50%{opacity:1} 51%,100%{opacity:.4} }

        /* Autocomplete suggestion overlay */
        .autocomplete-suggestion {
            position: absolute;
            pointer-events: none;
            color: rgba(38, 255, 0, 1);
            font-family: 'IBM VGA', 'Courier', monospace;
            z-index: 1;
            white-space: pre;
        }

        #input{
        background:transparent;
        border:none;
        border-bottom:1px solid rgba(57,255,20,.35);
        padding:10px 8px 6px 22px;          /* room for '>' */
        font: inherit;
        color: var(--phosphor);
        caret-color: var(--phosphor);
        box-shadow:none;
        text-shadow:
            0 0 1px var(--phosphor),
            0 0 10px rgba(57,255,20,.28),
            0 0 24px rgba(57,255,20,.12);
        }
        #input::placeholder{ color: rgba(57,255,20,.35); }

        /* Buttons look like lit keys */
        button{
        background: rgba(0,0,0,.5);
        color: var(--phosphor);
        border: 1px solid rgba(57,255,20,.35);
        border-radius: 6px;
        text-shadow:
            0 0 1px var(--phosphor),
            0 0 10px rgba(57,255,20,.28);
        box-shadow:
            0 0 0 1px rgba(57,255,20,.12) inset,
            0 0 24px rgba(57,255,20,.08) inset;
        transition: transform .06s ease, box-shadow .12s ease, background .12s ease;
        }
        button:hover{ background: rgba(57,255,20,.12); box-shadow: 0 0 40px rgba(57,255,20,.18) inset; }
        button:active{ transform: translateY(1px); }

        /* Colors that already exist, with a touch of glow */
        .prompt  { text-shadow: 0 0 1px #dfff8f, 0 0 12px rgba(223,255,143,.5); }
        .error   { text-shadow: 0 0 1px rgb(255,149,0), 0 0 12px rgba(255,149,0,.5); }
        .success { text-shadow: 0 0 1px rgb(201,255,207), 0 0 12px rgba(201,255,207,.5); }
        .system  { text-shadow: 0 0 1px rgb(9,255,0), 0 0 10px rgba(9,255,0,.5); }

        /* === Fullscreen page & container === */
        html, body { height: 100%; margin: 0; }
        body { padding: 0; }

        /* #game-container covers the whole screen */
        #game-container{
        position: fixed; inset: 0;                 /* full viewport */
        max-width: none;                            /* no centering limit */
        padding: 24px;                              /* screen bezel padding */
        display: block;                             /* keep overlays positioned */
        border-radius: 16px;
        }

        /* Two-column layout inside the curved screen:
        left = title/dropdown/output/input (2/3), right = image + inventory (1/3) */
        .crt-screen{
        position: relative;
        height: 100%;
        display: grid;
        grid-template-columns: 2fr 1fr;             /* 2/3 : 1/3 */
        grid-template-rows: auto 1fr auto auto;     /* title | output | dropdown (hidden) | input */
        gap: 16px;
        z-index: 0;                                 /* overlays sit above */
        backface-visibility: hidden;
        }

        /* When touch mode is active, give dropdown 1/3 of space */
        .crt-screen:has(#dropdown-container.active){
        grid-template-rows: auto 2fr 1fr auto;      /* title | output (2/3) | dropdown (1/3) | input */
        }

        /* Right sidebar container for image and inventory */
        #right-sidebar {
            grid-column: 2;
            grid-row: 1 / span 3;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Room image at top of sidebar */
        #room-image {
            width: 100%;
            height: auto;
            border-radius: 12px;
            border: 1px solid rgba(57,255,20,.25);
            display: block;
            flex-shrink: 0;
            position: relative;
        }

        /* Image transition overlay with scanline effect */
        #room-image-container {
            position: relative;
            overflow: visible;
            width: 100%;
        }

        .image-transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            pointer-events: none;
            z-index: 10;
        }

        .scanline-wipe {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(57,255,20,.8);
            box-shadow:
                0 0 8px rgba(57,255,20,1),
                0 0 16px rgba(57,255,20,.8),
                0 0 24px rgba(57,255,20,.4);
            z-index: 11;
        }

        .scanline-dot {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: rgba(255,255,255,1);
            border-radius: 50%;
            box-shadow:
                0 0 12px rgba(57,255,20,1),
                0 0 24px rgba(57,255,20,.8),
                0 0 36px rgba(57,255,20,.4);
            z-index: 12;
        }

        /* Location name under image */
        #location-name {
            text-align: center;
            margin: 0 auto;
            padding: 8px 16px;
            border: 1px solid rgba(57,255,20,.25);
            border-radius: 8px;
            background: rgba(0,0,0,.9);
            letter-spacing: 2px;
            text-shadow:
                0 0 1px var(--phosphor),
                0 0 6px rgba(57,255,20,.45),
                0 0 18px rgba(57,255,20,.15);
            position: relative;
            transform: translateY(-50%);
            width: fit-content;
            max-width: 90%;
        }

        /* Place areas */
        #title{ grid-column: 1; grid-row: 1; }
        #output{
        grid-column: 1; grid-row: 2;
        overflow-y: auto;
        /* override earlier fixed sizes so it grows with the grid */
        max-height: none !important;
        min-height: 0 !important;
        }
        #dropdown-container{ grid-column: 1; grid-row: 3; }
        #input-container{ grid-column: 1; grid-row: 4; }

        /* Inventory panel below image, takes remaining space */
        #inventory{
        margin: 0;
        padding: 12px 12px 12px 16px;
        border: 1px solid rgba(57,255,20,.25);
        border-radius: 12px;
        background: rgba(0,0,0,.35);
        overflow: auto;
        flex: 1;
        min-height: 0;
        }
        #inventory h3{
        position: sticky; top: 0;
        background: #000; padding-bottom: 8px; margin: 0 0 12px;
        z-index: 1;
        border-bottom: 1px dashed rgba(57,255,20,.35);
        }

        /* Make the input line fit the new layout */
        #input{ width: 100%; }

        /* Responsive fallback: stack on narrow screens */
        @media (max-width: 900px){
        .crt-screen{ grid-template-columns: 1fr; grid-template-rows: auto 1fr auto auto; }
        #inventory{ grid-column: 1; grid-row: 4; }
        }

        /* Static noise texture using CSS (no animation for performance) */
        .crt-noise{
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
            opacity: .025;
            mix-blend-mode: screen;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23n)" opacity="1"/></svg>');
            background-size: 200px 200px;
        }

        /* Touch Mode Dropdown Styles */
        #dropdown-container {
            display: none;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 20, 0, 0.95);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            min-height: 0;
        }

        #dropdown-container.active {
            display: flex;
        }

        .dropdown-stage {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dropdown-stage-title {
            color: #0f0;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dropdown-options {
            display: grid;
            gap: 6px;
        }

        /* Verb buttons - compact single words */
        .dropdown-options.verb-options {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        }

        /* Object buttons - wider to fit longer names */
        .dropdown-options.object-options {
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        }

        /* Default for other cases */
        .dropdown-options:not(.verb-options):not(.object-options) {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .dropdown-option {
            background: rgba(15, 255, 15, 0.1);
            border: 1px solid rgba(15, 255, 15, 0.3);
            color: rgb(69, 191, 69);
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 16px;
            text-align: center;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropdown-option:hover {
            background: rgba(255, 255, 0, 0.2);
            border-color: #ff0;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.3);
        }

        .dropdown-option.dropdown-cancel:hover {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.3);
        }

        /* On-screen keyboard */
        .on-screen-keyboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .keyboard-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .keyboard-letters {
            display: flex;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }

        /* First row shift left by one key width */
        .keyboard-row:first-child .keyboard-letters {
            margin-left: -50px;
        }

        .keyboard-key {
            min-width: 44px;
            min-height: 44px;
            background: rgba(15, 255, 15, 0.1);
            border: 1px solid rgba(15, 255, 15, 0.3);
            color: rgb(69, 191, 69);
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .keyboard-key:hover {
            background: rgba(255, 255, 0, 0.2);
            border-color: #ff0;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.3);
        }

        .keyboard-action {
            min-width: 100px;
            background: rgba(15, 255, 15, 0.15);
        }

        .keyboard-space-letter {
            min-width: 88px;
        }

        .keyboard-action.keyboard-cancel:hover {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.3);
        }

        .dropdown-option:active {
            transform: scale(0.95);
        }

        /* Touch mode button styling */
        #touch-mode-btn.active {
            background: rgba(15, 255, 15, 0.3);
            box-shadow: 0 0 10px rgba(15, 255, 15, 0.5);
        }

        /* Disable input in touch mode */
        #input.touch-mode {
            background: rgba(0, 0, 0, 0.5);
            cursor: not-allowed;
            user-select: none;
        }

    </style>
</head>
<body>
    <!-- SVG filter for barrel distortion -->
    <svg width="0" height="0" style="position:absolute;left:-9999px;top:-9999px">
        <filter id="crt-warp" x="-10%" y="-10%" width="120%" height="120%">
            <feTurbulence type="fractalNoise" baseFrequency="0.00015 0.003" numOctaves="1" seed="2" result="noise"/>
            <feGaussianBlur in="noise" stdDeviation="2" result="softNoise"/>
            <feDisplacementMap in="SourceGraphic" in2="softNoise" scale="34" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
    </svg>

    <div id="game-container">
        <!-- overlays stay OUTSIDE the warped area -->
        <div class="crt-scanline" aria-hidden="true"></div>
        <div class="crt-flicker"  aria-hidden="true"></div>
        <div class="crt-noise" aria-hidden="true"></div>

        <!-- NEW: only this part gets curved -->
        <div class="crt-screen">
            <div id="title">LA FORTALEZA</div>
            <div id="output"></div>
            <div id="dropdown-container"></div>
            <div id="input-container">
            <input type="text" id="input" placeholder="Escribe tu comando aquÃ­..." autocomplete="off" autofocus>
            <button onclick="processCommand()">ENVIAR</button>
            <button id="touch-mode-btn" onclick="toggleTouchMode()" title="Toggle Touch Mode">ðŸ“±</button>
            <button id="fullscreen-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen">â›¶</button>
            </div>
            <div id="right-sidebar">
                <div id="room-image-container">
                    <img id="room-image" src="images/room_entrance.jpg" alt="Room">
                </div>
                <div id="location-name">EXTERIOR DE LA FORTALEZA</div>
            </div>
        </div>
    </div>


    <script>
        // ==================== ROOM IMAGE MAPPING ====================

        const roomImages = {
            'el exterior de la fortaleza': ['images/room_entrance.jpg'],
            'el SalÃ³n de recepciones': ['images/room_reception.jpg'],
            'la Sala de juegos': ['images/room_game.jpg'],
            'el Patio interior': ['images/room_patio.jpg', 'images/room_patio_2.jpg'],
            'el JardÃ­n': ['images/room_gardens.jpg', 'images/room_gardens_2.jpg'],
            'la Biblioteca': ['images/room_library.jpg'],
            'el Cuarto de espejos': ['images/room_mirrors.jpg'],
            'Pasillo': ['images/room_pasillo.jpg'],
            'la Alcoba de la bruja': ['images/room_witch.jpg'],
            'el Cuarto del guerrero': ['images/room_warrior.jpg'],
            'el Laboratorio de la Bestia': ['images/room_lab.jpg'],
            'la Sala de armas': ['images/room_armory.jpg'],
            'los BaÃ±os de la Bestia': ['images/room_bathroom.jpg'],
            'la Alcoba de la doncella': ['images/room_maid.jpg'],
            'la Sala de infusiones': ['images/room_tearoom.jpg'],
            'los Calabozos': ['images/room_jail.jpg'],
            'los Almacenes de la Fortaleza': ['images/room_warehouse.jpg'],
            'SalÃ³n de cristal': ['images/room_crystal.jpg'],
            'Boca de la Bestia': ['images/room_mouth.jpg'],
            'Interior de la Bestia': ['images/room_beast_interior.jpg'],
            'Pulmones de la Bestia': ['images/room_lungs.jpg'],
            'el EstÃ³mago de la Bestia': ['images/room_stomach.jpg'],
            'el CorazÃ³n de la Bestia': ['images/room_heart.jpg'],
            'el Cerebro de la Bestia': ['images/room_brain.jpg'],
            'un extenso pÃ¡ramo': ['images/room_moor.jpg'],
            'celda pequeÃ±a': ['images/room_labrynth_cell.jpg'],
            'un puente de mÃ¡rmol': ['images/room_marble_bridge.jpg'],
            'la Antesala del Laberinto': ['images/room_labrynth_entrance.jpg'],
            'la cueva del Minotauro': ['images/room_minotaur.jpg'],
            'el SalÃ³n de los elegidos': ['images/room_chosen.jpg'],
            'un pasillo del Laberinto': ['images/room_labrynth_node_1.jpg', 'images/room_labrynth_node_2.jpg', 'images/room_labrynth_node_3.jpg', 'images/room_labrynth_node_4.jpg']
        };

        function getRandomRoomImage(roomName) {
            const images = roomImages[roomName];
            if (images && images.length > 0) {
                const randomIndex = Math.floor(Math.random() * images.length);
                return images[randomIndex];
            }
            return 'images/room_entrance.jpg'; // Default fallback
        }

        window.updateRoomImage = function(roomName) {
            const imageElement = document.getElementById('room-image');
            const container = document.getElementById('room-image-container');
            if (!imageElement || !container) return;

            const newSrc = getRandomRoomImage(roomName);

            // Don't animate if it's the same image
            if (imageElement.src.endsWith(newSrc)) return;

            // Create overlay and scanline elements
            const overlay = document.createElement('div');
            overlay.className = 'image-transition-overlay';

            const scanline = document.createElement('div');
            scanline.className = 'scanline-wipe';
            scanline.style.top = '0px';

            const dot = document.createElement('div');
            dot.className = 'scanline-dot';
            scanline.appendChild(dot);

            container.appendChild(overlay);
            container.appendChild(scanline);

            // Preload new image
            const newImage = new Image();
            newImage.onload = () => {
                // Start the scanline animation
                const imageHeight = imageElement.offsetHeight;
                const duration = 800; // ms
                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Ease-in-out for smoother motion
                    const eased = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    const currentY = eased * imageHeight;
                    scanline.style.top = currentY + 'px';

                    // Clip the overlay to reveal image progressively
                    overlay.style.clipPath = `inset(${currentY}px 0 0 0)`;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation complete, clean up
                        container.removeChild(overlay);
                        container.removeChild(scanline);
                    }
                }

                // Change the image source and start animation
                imageElement.src = newSrc;
                requestAnimationFrame(animate);
            };

            newImage.src = newSrc;
        }

        // ==================== HELPER FUNCTIONS ====================

        // Normalize string to remove accents for easier matching
        function normalizeString(str) {
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // ==================== SAVE/LOAD SYSTEM ====================
        // Command-based save system: saves the history of state-changing commands
        // and replays them on load to reconstruct the exact game state

        // Commands that don't change state and should not be saved
        const READ_ONLY_COMMANDS = ['mirar', 'ver', 'observar', 'examinar', 'inventario', 'inv',
                                     'hablar', 'ayuda', 'help', 'partidas', 'pistas'];

        // Dictionary for compressing common words in commands
        // Using special Unicode characters to avoid conflicts
        const COMPRESSION_DICT = {
            'tomar': '\u00A1', 'coger': '\u00A2', 'ir': '\u00A3', 'puerta': '\u00A4',
            'matar': '\u00A5', 'dar': '\u00A6', 'abrir': '\u00A7', 'romper': '\u00A8',
            'dejar': '\u00A9', 'soltar': '\u00AA', 'atravesar': '\u00AB', 'cuarto': '\u00AC',
            'pasillo': '\u00AD', 'laboratorio': '\u00AE', 'jardin': '\u00AF', 'biblioteca': '\u00B0',
            'espejo': '\u00B1', 'guerrero': '\u00B2', 'hacha': '\u00B3', 'espada': '\u00B4',
            'daga': '\u00B5', 'principal': '\u00B6', 'con': '\u00B7'
        };

        function shouldSaveCommand(command) {
            const cmd = command.trim().toLowerCase();
            // Don't save load/save commands
            if (cmd.startsWith('cargar') || cmd.startsWith('guardar') || cmd.startsWith('borrar')) {
                return false;
            }
            // Don't save read-only commands
            const firstWord = cmd.split(' ')[0];
            return !READ_ONLY_COMMANDS.includes(firstWord);
        }

        function compressCommands(commands) {
            return commands.map(cmd => {
                let compressed = cmd;
                // Replace each word with its Unicode character
                for (let [word, char] of Object.entries(COMPRESSION_DICT)) {
                    compressed = compressed.replace(new RegExp('\\b' + word + '\\b', 'gi'), char);
                }
                return compressed;
            });
        }

        function decompressCommands(commands) {
            // Build reverse dictionary
            const reverse = {};
            for (let [word, char] of Object.entries(COMPRESSION_DICT)) {
                reverse[char] = word;
            }

            return commands.map(cmd => {
                let decompressed = cmd;
                // Replace each Unicode character back with its word
                for (let [char, word] of Object.entries(reverse)) {
                    decompressed = decompressed.replace(new RegExp(char, 'g'), word);
                }
                return decompressed;
            });
        }

        function serializeGameState() {
            // Compress command history before saving
            const compressed = compressCommands(gameState.commandHistory);
            const state = {
                commands: compressed,
                timestamp: new Date().toISOString()
            };

            // Debug logging
            console.log('[SAVE] Original commands:', gameState.commandHistory);
            console.log('[SAVE] Compressed commands:', compressed);
            console.log('[SAVE] Current room:', gameState.player.here ? gameState.player.here.name : 'none');

            return JSON.stringify(state);
        }

        function deserializeGameState(stateStr) {
            try {
                const state = JSON.parse(stateStr);

                // Decompress commands
                const commands = decompressCommands(state.commands);

                // Debug logging
                console.log('[LOAD] Compressed commands from save:', state.commands);
                console.log('[LOAD] Decompressed commands:', commands);
                console.log('[LOAD] Number of commands to replay:', commands.length);

                // Reset the game completely (silent mode - no welcome message or initial look)
                initGame(true);
                console.log('[LOAD] Game initialized, player at room:', gameState.player.here ? gameState.player.here.name : 'none');

                // Suppress output and images during replay
                const originalPrintLine = window.printLine;
                const originalUpdateRoomImage = window.updateRoomImage;

                window.printLine = function() {}; // Completely suppress output during replay
                window.updateRoomImage = function() {}; // Suppress image changes during replay

                // Replay all commands silently and rebuild command history
                let commandCount = 0;
                for (let cmd of commands) {
                    commandCount++;
                    console.log(`[LOAD] Replaying command ${commandCount}/${commands.length}: "${cmd}"`);
                    console.log(`[LOAD] Before command - Room: ${gameState.player.here ? gameState.player.here.name : 'none'}`);

                    if (gameState.player.dead) {
                        console.log('[LOAD] Player died during replay, stopping');
                        break;
                    }

                    executeCommand(cmd);

                    // CRITICAL: Rebuild command history during replay
                    // This ensures subsequent saves include all commands
                    if (shouldSaveCommand(cmd)) {
                        gameState.commandHistory.push(cmd);
                    }

                    console.log(`[LOAD] After command - Room: ${gameState.player.here ? gameState.player.here.name : 'none'}`);
                }

                console.log('[LOAD] Replay complete. Final room:', gameState.player.here ? gameState.player.here.name : 'none');
                console.log('[LOAD] Rebuilt command history length:', gameState.commandHistory.length);

                // Restore output functions
                window.printLine = originalPrintLine;
                window.updateRoomImage = originalUpdateRoomImage;

                // Clear the output display
                const output = document.getElementById('output');
                output.innerHTML = '';

                // Show success message
                printLine('Partida cargada exitosamente.', 'success');
                printLine('');

                // Show current room state and update image
                gameState.player.look();

                return true;
            } catch (e) {
                printLine('Error al cargar la partida: ' + e.message, 'error');
                console.error('[LOAD] Error:', e);
                return false;
            }
        }

        function listSaves() {
            const saves = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('fortaleza_save_')) {
                    const saveName = key.replace('fortaleza_save_', '');
                    const saveData = localStorage.getItem(key);
                    try {
                        const state = JSON.parse(saveData);
                        saves.push({
                            name: saveName,
                            timestamp: state.timestamp
                        });
                    } catch (e) {
                        // Skip invalid saves
                    }
                }
            }
            // Sort by timestamp descending (newest first)
            saves.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return saves;
        }

        function saveGame(saveName) {
            if (!saveName || saveName.trim() === '') {
                printLine('Debe proporcionar un nombre para el juego.', 'error');
                return;
            }

            const key = 'fortaleza_save_' + saveName.trim();
            const state = serializeGameState();

            try {
                localStorage.setItem(key, state);
                printLine('Juego guardado como: ' + saveName, 'success');
            } catch (e) {
                printLine('Error al guardar: ' + e.message, 'error');
            }
        }

        function loadGame(saveName) {
            if (!saveName || saveName.trim() === '') {
                printLine('Debe proporcionar un nombre de juego.', 'error');
                return;
            }

            const key = 'fortaleza_save_' + saveName.trim();
            const state = localStorage.getItem(key);

            if (!state) {
                printLine('No existe un juego con ese nombre.', 'error');
                return;
            }

            if (deserializeGameState(state)) {
                // deserializeGameState already shows success message and calls look()
                // Just update the inventory display
                updateInventory();
            }
        }

        function deleteSave(saveName) {
            if (!saveName || saveName.trim() === '') {
                printLine('Debe proporcionar un nombre de juego.', 'error');
                return;
            }

            const key = 'fortaleza_save_' + saveName.trim();

            if (!localStorage.getItem(key)) {
                printLine('No existe un juego con ese nombre.', 'error');
                return;
            }

            localStorage.removeItem(key);
            printLine('Juego eliminado: ' + saveName, 'success');
        }

        function showSaves() {
            const saves = listSaves();

            if (saves.length === 0) {
                printLine('No hay juegos guardados.', 'system');
                return;
            }

            printLine('Juegos guardados:', 'system');
            saves.forEach(save => {
                const date = new Date(save.timestamp);
                const dateStr = date.toLocaleString('es-ES');
                printLine('  - ' + save.name + ' (' + dateStr + ')');
            });
        }

        // ==================== OBJECT CLASSES ====================

        // Base Thing class
        class Thing {
            constructor(name, desc, mass) {
                this.name = name;
                this.desc = desc;
                this.mass = mass;
                this.items = [];
            }

            image() {
                return this.desc;
            }

            get(nm) {
                const normalized = normalizeString(nm.toLowerCase().trim());

                // First, try exact match
                let exactMatch = this.items.find(item => {
                    const itemName = normalizeString(item.name.toLowerCase());
                    return itemName === normalized;
                });
                if (exactMatch) return exactMatch;

                // Then find all partial matches where item name starts with the search term
                let matches = this.items.filter(item => {
                    const itemName = normalizeString(item.name.toLowerCase());
                    return itemName.startsWith(normalized);
                });

                // If we have matches, return the shortest one (most specific)
                if (matches.length > 0) {
                    return matches.reduce((shortest, current) =>
                        current.name.length < shortest.name.length ? current : shortest
                    );
                }

                // Finally, try substring match (item name contains search term)
                return this.items.find(item => {
                    const itemName = normalizeString(item.name.toLowerCase());
                    return itemName.includes(normalized);
                });
            }

            take(nm) {
                const item = this.get(nm);
                if (item) {
                    this.items = this.items.filter(i => i !== item);
                }
                return item;
            }

            insert(item) {
                this.items.push(item);
            }
        }

        // LivingThing class
        class LivingThing extends Thing {
            constructor(name, desc, mass) {
                super(name, desc, mass);
                this.dead = false;
            }

            speak() {
                printLine('...');
            }

            die(weapon) {
                this.dead = true;
                return true;
            }

            accept(gift) {
                // abstract
            }
        }

        // Troll class
        class Troll extends LivingThing {
            constructor(name, desc, likeness, hiData, lowData) {
                super(name, desc, 100);
                this.likeness = likeness;
                this.hiData = hiData;
                this.lowData = lowData;
                this.happy = false;
            }

            speak() {
                if (this.happy) {
                    printLine(this.hiData);
                } else {
                    printLine(this.lowData);
                }
            }

            accept(gift) {
                this.happy = gift.name.toLowerCase() === this.likeness.toLowerCase();
                if (this.happy) {
                    printLine('Â¡Muchas muchas gracias!');
                } else {
                    printLine('Gracias.');
                }
            }

            die(weapon) {
                printLine('Â¡Ahhhhhhh!');
                return super.die(weapon);
            }
        }

        // Guard class
        class Guard extends LivingThing {
            constructor(name, desc, confession, lethalWeapon) {
                super(name, desc, 999);
                this.confession = confession;
                this.lethalWeapon = lethalWeapon;
            }

            die(weapon) {
                const weaponName = weapon ? weapon.toLowerCase() : '';
                const lethalName = this.lethalWeapon ? this.lethalWeapon.toLowerCase() : '';

                // Weapon must match exactly (Pascal uses Equals function)
                if (weaponName === lethalName) {
                    printLine(this.confession);
                    return super.die(weapon);
                } else {
                    printLine('Â¡Ja ja ja! Â¡Eso no me harÃ¡ daÃ±o!');
                    return false;
                }
            }
        }

        // Linking class (doors, passages)
        class Linking extends Thing {
            constructor(name, desc, key, passComment, destination) {
                super(name, desc, 999);
                this.destination = destination;
                this.passComment = passComment;
                this.key = key || '';
                this.open = (key === '' || key === null);
            }

            openDoor(psKey) {
                if (this.key === '' || psKey.toLowerCase().includes(this.key.toLowerCase())) {
                    this.open = true;
                    return true;
                }
                return false;
            }

            pass(body) {
                if (this.passComment) {
                    printLine(this.passComment);
                }
            }

            dest() {
                return this.open ? this.destination : null;
            }
        }

        // OpenLink class (always open)
        class OpenLink extends Linking {
            constructor(name, desc, passComment, destination) {
                super(name, desc, '', passComment, destination);
                this.open = true;
            }
        }

        // DangerLink class (requires talisman)
        class DangerLink extends Linking {
            constructor(name, desc, key, passComment, talisman, destination) {
                super(name, desc, key, passComment, destination);
                this.talisman = talisman;
            }

            pass(body) {
                const player = gameState.player;
                const item = player.bag.get(this.talisman);
                if (!item) {
                    printLine('No tiene protecciÃ³n. Usted muere.');
                    player.die('');
                    gameState.gameOver = true;
                } else {
                    super.pass(body);
                }
            }
        }

        // DangerLink2 class (kills if you have item)
        class DangerLink2 extends DangerLink {
            pass(body) {
                const player = gameState.player;
                const item = player.bag.get(this.talisman);
                if (item) {
                    printLine('El objeto ' + this.talisman + ' lo mata.');
                    player.die('');
                    gameState.gameOver = true;
                } else {
                    Linking.prototype.pass.call(this, body);
                }
            }
        }

        // RiddleLink class (requires answer)
        class RiddleLink extends Linking {
            constructor(name, desc, riddle, answer, passComment, destination) {
                super(name, desc, '', passComment, destination);
                this.riddle = riddle;
                this.answer = answer;
                this.open = false;  // RiddleLinks start closed
            }

            openDoor(psKey) {
                if (psKey.toLowerCase() === this.answer.toLowerCase()) {
                    printLine('Â¡Ha resuelto el acertijo!');
                    this.open = true;
                    return true;
                } else {
                    if (psKey === '') {
                        printLine('Debe resolver el acertijo primero:');
                        printLine(this.riddle);
                    } else {
                        printLine('Respuesta incorrecta. El acertijo es:');
                        printLine(this.riddle);
                    }
                    return false;
                }
            }
        }

        // Hidden class (reveals hidden thing when broken)
        class Hidden extends Thing {
            constructor(name, desc, breaker, hiddenThing) {
                super(name, desc, 999);
                this.breaker = breaker;
                this.hiddenThing = hiddenThing;
            }

            breakWith(weapon) {
                if (!this.breaker || weapon.toLowerCase().includes(this.breaker.toLowerCase())) {
                    return true;
                }
                return false;
            }
        }

        // Room class
        class Room extends Thing {
            constructor(name, desc) {
                super(name, desc, 999);
                this.visited = false;
            }

            describe() {
                if (this.items.length > 0) {
                    const itemNames = this.items.map(i => i.name).join(', ');
                    printLine('Ves aquÃ­: ' + itemNames);
                }
            }

            openItem(nm, psKey) {
                const item = this.get(nm);
                if (item && (item instanceof Linking || item instanceof RiddleLink)) {
                    if (item.open) {
                        printLine('Ya estÃ¡ abierto.');
                    } else {
                        if (item.openDoor(psKey)) {
                            // Auto-open reverse link (matches Pascal behavior at CASTLES.PAS:410-416)
                            if (item.destination && item.destination instanceof Room) {
                                const reverseLink = item.destination.get(nm);
                                if (reverseLink && (reverseLink instanceof Linking ||
                                    reverseLink instanceof DangerLink || reverseLink instanceof DangerLink2 ||
                                    reverseLink instanceof RiddleLink || reverseLink instanceof OpenLink)) {
                                    reverseLink.openDoor(psKey);
                                }
                            }
                            printLine('Ok.');
                        } else {
                            printLine('No puede abrir esto.');
                            if (psKey === '') {
                                printLine('Necesita una palabra clave.');
                            } else {
                                printLine('"' + psKey + '" no es la palabra correcta.');
                            }
                        }
                    }
                } else if (item) {
                    // Item exists but is not a link/door
                    printLine('No puede abrir esto.');
                } else if (nm) {
                    printLine('No puede hacer eso. No hay "' + nm + '" en esta habitaciÃ³n.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            breakItem(nm, weapon) {
                const item = this.get(nm);
                if (item && item instanceof Hidden) {
                    if (item.breakWith(weapon)) {
                        const hidden = item.hiddenThing;
                        this.items = this.items.filter(i => i !== item);
                        this.items.push(hidden);
                        printLine('Â¡Crash! Usted ha roto ' + item.name + '.');
                        printLine('Â¡Sorpresa! Ha encontrado: ' + hidden.name);
                    } else {
                        printLine('Usted trata, pero no lo consigue.');
                    }
                } else if (nm) {
                    printLine('No se puede romper eso.');
                } else {
                    printLine('Complete su frase.');
                }
            }
        }

        // Suitcase class (inventory)
        class Suitcase extends Room {
            constructor() {
                super('Mochila', 'Su mochila');
            }

            empty() {
                return this.items.length === 0;
            }

            heaviness() {
                return this.items.reduce((sum, item) => sum + item.mass, 0);
            }

            describe() {
                if (this.empty()) {
                    return;
                }
                for (let item of this.items) {
                    printLine(item.name + ' (' + item.mass + ')');
                }
                const remaining = gameState.maxWeight - this.heaviness();
                if (remaining === 0) {
                    printLine('No puede cargar nada mÃ¡s.');
                } else if (remaining === 1) {
                    printLine('EstÃ¡ a punto de agotar sus capacidades.');
                } else {
                    printLine('PodrÃ­a cargar ' + remaining + ' bolsas mÃ¡s.');
                }
            }
        }

        // Man class (player)
        class Man extends LivingThing {
            constructor(name, desc) {
                super(name, desc, 0);
                this.curr = null;
                this.bag = new Suitcase();
                this.visits = 0;
                this.firstLook = true;
            }

            go(newRoom) {
                if (this.dead) return;
                this.curr = newRoom;
                if (!newRoom.visited) {
                    newRoom.visited = true;
                    this.visits++;
                }
            }

            look(clearHistory = false) {
                if (this.dead) return;

                // Clear output only when explicitly requested (mirar command)
                if (clearHistory && !this.firstLook) {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                }

                if (this.firstLook) {
                    this.firstLook = false;
                }

                printLine('');
                printLine('EstÃ¡s en ' + this.curr.name + '.', 'success');
                printLine(this.curr.desc);
                printLine('');
                this.curr.describe();

                // Update location name display
                const locationElement = document.getElementById('location-name');
                if (locationElement) {
                    locationElement.textContent = this.curr.name.toUpperCase();
                }

                // Update room image
                updateRoomImage(this.curr.name);

                // Do NOT Show exits
                /*
                const exits = this.curr.items.filter(i =>
                    i instanceof Linking ||
                    i instanceof OpenLink ||
                    i instanceof DangerLink ||
                    i instanceof DangerLink2 ||
                    i instanceof RiddleLink
                );
                if (exits.length > 0) {
                    const exitNames = exits.map(e => e.name).join(', ');
                    printLine('');
                    printLine('Salidas: ' + exitNames);
                }
                printLine('');
                */
            }

            inventary() {
                if (this.dead) return;
                if (!this.bag.empty()) {
                    printLine('Sus pertenecias son:');
                    this.bag.describe();
                } else {
                    printLine('Usted no lleva nada consigo.');
                }
            }

            see(what) {
                if (this.dead) return;
                if (!what) {
                    printLine('Â¿QuÃ© quieres ver?');
                    return;
                }

                let item = this.curr.get(what);
                if (item) {
                    printLine(item.image());
                } else {
                    item = this.bag.get(what);
                    if (item) {
                        printLine(item.image());
                    } else {
                        printLine('No existe "' + what + '" en este lugar. Entre sus pertenencias tampoco.');
                    }
                }
            }

            take(what) {
                if (this.dead) return;
                const item = this.curr.get(what);
                if (item) {
                    if (item.mass > gameState.maxWeight) {
                        printLine('Usted no puede cargar con eso.');
                    } else if (this.bag.heaviness() + item.mass <= gameState.maxWeight) {
                        this.bag.insert(this.curr.take(what));
                        printLine('Ok.');
                        updateInventory();
                    } else {
                        printLine('SerÃ­a demasiado peso.');
                    }
                } else if (what) {
                    printLine('No existe "' + what + '" en este lugar.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            leave(what) {
                if (this.dead) return;
                const item = this.bag.get(what);
                if (item) {
                    this.curr.insert(this.bag.take(what));
                    printLine('Ok.');
                    updateInventory();
                } else if (what) {
                    printLine('"' + what + '" no estÃ¡ dentro de sus pertenencias.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            leaveAll() {
                if (this.dead) return;
                if (this.bag.empty()) {
                    printLine('Usted no lleva nada consigo.');
                } else {
                    while (!this.bag.empty()) {
                        const item = this.bag.items[0];
                        this.curr.insert(this.bag.take(item.name));
                    }
                    printLine('Usted deja todas sus pertencias en el suelo.');
                    updateInventory();
                }
            }

            openD(door, key) {
                if (this.dead) return;
                if (key) {
                    printLine('Invocas las palabras mÃ¡gicas:');
                    printLine(key + '!!!');
                }
                this.curr.openItem(door, key);
            }

            walkT(door) {
                if (this.dead) return;
                const link = this.curr.get(door);
                if (link && (link instanceof Linking || link instanceof OpenLink ||
                    link instanceof DangerLink || link instanceof DangerLink2 ||
                    link instanceof RiddleLink)) {
                    const nextRoom = link.dest();
                    if (nextRoom) {
                        // Get the output element to preserve recent messages
                        const output = document.getElementById('output');
                        const lines = Array.from(output.children);

                        // Find the last prompt (user command) - it should be the most recent line
                        let lastPromptIndex = -1;
                        for (let i = lines.length - 1; i >= 0; i--) {
                            if (lines[i].classList.contains('prompt')) {
                                lastPromptIndex = i;
                                break;
                            }
                        }

                        // Clear output but keep the command and any messages after it
                        if (lastPromptIndex >= 0) {
                            const linesToKeep = lines.slice(lastPromptIndex);
                            output.innerHTML = '';
                            linesToKeep.forEach(line => output.appendChild(line));
                        }

                        this.go(nextRoom);
                        link.pass(this);
                        // Check if player died from passing through the link
                        if (!this.dead) {
                            this.look();
                        }
                    } else {
                        printLine('Â¡Auch! Te golpeas la cabeza.');
                        printLine('SerÃ­a mÃ¡s fÃ¡cil si primero abrieras la puerta.');
                    }
                } else if (door) {
                    printLine('No puedes atravesar eso.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            kill(who, weapon) {
                if (this.dead) return;
                const target = this.curr.get(who);
                if (target && (target instanceof Troll || target instanceof Guard)) {
                    if (weapon && !this.bag.get(weapon)) {
                        printLine('"' + weapon + '" no estÃ¡ dentro de sus pertenencias.');
                        return;
                    }
                    if (target.die(weapon)) {
                        this.curr.items = this.curr.items.filter(i => i !== target);
                    }
                } else if (who) {
                    printLine('"' + who + '" no estÃ¡ aquÃ­.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            ask(who) {
                if (this.dead) return;
                const target = this.curr.get(who);
                if (target && (target instanceof Troll || target instanceof Guard)) {
                    target.speak();
                } else if (who) {
                    printLine('"' + who + '" no estÃ¡ aquÃ­.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            give(what, who) {
                if (this.dead) return;
                if (this.bag.empty()) {
                    printLine('Usted no lleva nada consigo.');
                    return;
                }

                const target = this.curr.get(who);
                if (target && target instanceof Troll) {
                    const item = this.bag.take(what);
                    if (item) {
                        target.accept(item);
                        updateInventory();
                    } else {
                        printLine('"' + what + '" no estÃ¡ dentro de sus pertenencias.');
                    }
                } else if (who) {
                    printLine('Ese regalo no es aceptado.');
                } else {
                    printLine('Â¿Para quiÃ©n es el regalo?');
                }
            }

            breakItem(what, how) {
                if (this.dead) return;
                if (how && !this.bag.get(how)) {
                    printLine('"' + how + '" no estÃ¡ dentro de sus pertenencias.');
                    return;
                }
                this.curr.breakItem(what, how);
            }

            weigh(what) {
                if (this.dead) return;
                if (!this.bag.get('Balanza')) {
                    printLine('Usted no trae la balanza.');
                    return;
                }

                let item = this.bag.get(what);
                if (!item) item = this.curr.get(what);

                if (item) {
                    if (item.name.toLowerCase() === 'balanza') {
                        printLine('Usted trata infructuosamente de colocar la balanza sobre ella misma.');
                    } else if (item.mass > gameState.maxWeight) {
                        printLine('Â¡Se ha vuelto loco! Â¿CÃ³mo va a pesar eso?');
                    } else {
                        const unit = item.mass === 1 ? 'bolsa' : 'bolsas';
                        printLine('Usted coloca el objeto en el plato de la balanza.');
                        printLine('La aguja indica ' + item.mass + ' ' + unit + '.');
                    }
                } else if (what) {
                    printLine('No hay "' + what + '" en este lugar. Ni en sus pertenencias tampoco.');
                } else {
                    printLine('Complete su frase.');
                }
            }

            die(weapon) {
                if (this.dead) return true;
                super.die(weapon);
                printLine('Lamento informarle que usted estÃ¡ muerto.');
                return true;
            }
        }

        // ==================== GAME STATE ====================

        const gameState = {
            player: null,
            rooms: [],
            currentRoom: null,
            gameOver: false,
            gameWon: false,
            maxWeight: 40
        };

        // Properly decoded keys from the original Turbo Pascal CP437 encoding
        // Original encoding: each character has 20 added to its CP437 byte value
        const decodedKeys = [
            '',  // key[0] - not used, placeholder for 1-indexed Pascal array
            'Hay un nombre que vas a necesitar mucho: Rumpelstinskin.',
            'Abrete Sesamo',
            'Ariete',
            'Maza',
            'Busca a la doncella al lado del espejo que romperÃ¡s con un hueso. Ella te dirÃ¡ dÃ³nde estÃ¡ el final de la Bestia.',
            'Treinta y nueve',
            'Lanza',
            'Para llegar a los pulmones de la Bestia debes tener el talisman de aire.',
            'Paraguas',
            'En la biblioteca hay un libro que conduce al jardÃ­n.',
            'Hueso de gato',
            ' Puedes pasar, la contraseÃ±a es "Nombus Rostomelaris"',
            'Maza',
            'Nombus Rostomelaris',
            'Luz',
            'Usted cae durante varios minutos y, gracias al candelabro, cuando toca el suelo no se hace daÃ±o. Oye una voz que dice: "Sea gentil con la doncella, regÃ¡lele una flor."',
            'Escucha bien, hijo. Cuando te digan "Prohibido", invoca la luz. Recuerda que la palabra crea a su significado.',
            'Hacha',
            'Pocion para crecer',
            'Para atravezar por el escaparate de la bruja, debes llevar un candelabro. Y al hacerlo vas a conocer algo importante.',
            'Polvo magico',
            'El corazÃ³n de unicornio te protegerÃ¡ en el corazÃ³n de la Bestia.',
            'Rumpelstinskin',
            'Rosa',
            'La Ãºltima habitaciÃ³n estÃ¡ al principio.',
            'Imnus humiscuol rastomislakis!! Con esta esapada matarÃ¡s a los pulmones de la Bestia.',
            'Espada',
            'Taza de cafe',
            'Al entrar al estÃ³mago, lleva contigo un pastel.',
            'Talisman de aire',
            'Pastel de cerezas',
            'Espada',
            'Latigo',
            'Daga',
            'Usted ha destruido los pulmones! Solo con un lÃ¡tigo podrÃ¡s destruir el estÃ³mago.',
            'Usted ha destruido el estÃ³mago! Solo con una daga podrÃ¡s destruir el corazÃ³n.',
            'Usted ha destruido el corazÃ³n! Busca el cerebro de la bestia lejos de aquÃ­. Solo el fuego puede destruirlo.',
            'Antorcha',
            'Â¿Mataste al Troll?',
            'Piedra filosofal',
            'Cuidado con el tÃºnel y la puerta de tela. Solo conducen a la muerte.',
            'Agua',
            'nada',
            'AAARRRRGGGG!!!! La palabra mÃ¡gica es "Agua".',
            'Arco',
            'Maquina del tiempo',
            'Solo con una daga podrÃ¡s matar el corazÃ³n.'
        ];

        function decodeLine(keyIndex) {
            // Return the properly decoded key by index
            return decodedKeys[keyIndex] || '';
        }

        // ==================== GAME INITIALIZATION ====================

        function initGame(silent = false) {
            // Reset command history for save system
            gameState.commandHistory = [];
            gameState.gameOver = false;
            gameState.gameWon = false;

            // Create player
            gameState.player = new Man('Indy', 'Aventurero');

            // Create all rooms
            createRooms();

            // Set starting room
            gameState.player.go(gameState.rooms[0]);

            if (!silent) {
                // Welcome message
                printLine('Bienvenido a LA FORTALEZA', 'success');
                printLine('');
                const hour = new Date().getHours();
                if (hour < 12) {
                    printLine('Buenos dÃ­as.');
                } else if (hour > 18) {
                    printLine('Buenas noches.');
                } else {
                    printLine('Buenas tardes.');
                }
                printLine('');
                printLine('Escribe "ayuda" para ver los comandos disponibles.');
                gameState.player.look();
            }
        }

        function createRooms() {
            // Create rooms
            const rooms = [];

            rooms[0] = new Room('el exterior de la fortaleza',
                'Las paredes son muy negras y al parecer, no tienen ventanas. Usted trata de ver el final de las torres, pero las nubes no se lo permiten.');

            rooms[1] = new Room('el SalÃ³n de recepciones',
                'Parece hecho para criaturas cientos de veces mÃ¡s grandes que los humanos. EstÃ¡ desierto, pero usted siente que es observado.');

            rooms[2] = new Room('la Sala de juegos',
                'Usted trata de imaginar cÃ³mo eran los juegos del salÃ³n. Hay doce mesas y cada una tiene doce erizos.');

            rooms[3] = new Room('el Patio interior',
                'El patio tiene forma de caracol. Cada uno o dos pasos se levanta una columna de mÃ¡rmol negro y se confunde en la altura con los Ã¡rboles. Usted siente el crujido de las hojas secas bajo sus zapatos.');

            rooms[4] = new Room('el Cuarto de espejos',
                'Hay tantos espejos que no puede reconocer si usted es real o es una imagen de sÃ­ mismo.');

            rooms[5] = new Room('la Biblioteca',
                'Hay miles de libros en este lugar. Todos tienen alguna hoja marcada con una servilleta. Los pasillos estan numerados usando el viejo alfabeto bestial ABCDEFGHIJKLMNOPQRSTUVWXYZ');

            rooms[6] = new Room('Pasillo',
                'Tiene tres puertas al lado y una al final.');

            rooms[7] = new Room('la Alcoba de la bruja',
                'Hasta un ciego descubrirÃ­a que aquÃ­ habita una bruja. El cuarto tiene una ventana, pero usted no recuerda haberla visto desde afuera.');

            rooms[8] = new Room('el Cuarto del guerrero',
                'El cuarto estÃ¡ muy ordenado. A usted le sorprende que no hayan armas.');

            rooms[9] = new Room('el Laboratorio de la Bestia',
                'Hay muchos frascos. A usted le llaman la atenciÃ³n los Ãºltimos: estÃ¡n llenos de homÃºnculos.');

            rooms[10] = new Room('la Sala de armas',
                'Este lugar parece salido del sueÃ±o de un guerrero.');

            rooms[11] = new Room('los BaÃ±os de la Bestia',
                'El baÃ±o es tan grande que usted no puede ver las paredes que lo limitan.');

            rooms[12] = new Room('el JardÃ­n',
                'Se podrÃ­an construir varias ciudades en su interior.');

            rooms[13] = new Room('la Alcoba de la doncella',
                'Es una habitaciÃ³n muy pequeÃ±a y hÃºmeda.');

            rooms[14] = new Room('la Sala de infusiones',
                'Hay varias mesas regadas por el suelo. Usted tiene la impresiÃ³n de que ningÃºn humano ha estado en ese lugar anteriormente.');

            rooms[15] = new Room('los Calabozos',
                'Son tan hÃºmedos que usted no resistirÃ­a ni unas horas dentro de ellos.');

            rooms[16] = new Room('Boca de la Bestia',
                'Es como una boca humana, pero del tamaÃ±o de una casa.');

            rooms[17] = new Room('Interior de la Bestia',
                'Usted puede sentir los latidos del corazÃ³n de la Bestia, al igual que su respiraciÃ³n o el ruido de los lÃ­quidos revueltos en su estÃ³mago.');

            rooms[18] = new Room('Pulmones de la Bestia',
                'Sopla un aire tan fuerte que usted se ha tirado al suelo.');

            rooms[19] = new Room('el EstÃ³mago de la Bestia',
                'Hay varios esqueletos humanos.');

            rooms[20] = new Room('el CorazÃ³n de la Bestia',
                'Todo palpita rÃ­tmicamente. Usted siente cÃ³mo los latidos se adueÃ±an del lugar, especialmente de su propio corazÃ³n.');

            rooms[21] = new Room('el Cerebro de la Bestia',
                'Es como un tarjetero gigante. Cada idea estÃ¡ escrita en una tarjeta y, cuando es necesario, la tarjeta es sacada por una mano invisible y leÃ­da al resto de la Bestia.');

            rooms[22] = new Room('los Almacenes de la Fortaleza',
                'EstÃ¡n llenos de carne humana. Usted aparta el cadÃ¡ver de una mujer para poder observar bien el lugar.');

            rooms[23] = new Room('un extenso pÃ¡ramo',
                'Hay muy poca vegetaciÃ³n y el suelo es pantanoso. Usted nunca imaginÃ³ que el interior de la fortaleza fuera tan grande.');

            rooms[24] = new Room('SalÃ³n de cristal',
                'Es como un caleidoscopio gigante. Cada varios segundos las paredes cambian de color y usted siente como si lo hubieran trasladado a otro lugar.');

            rooms[25] = new Room('celda pequeÃ±a',
                'Es una celda muy pequeÃ±a y oscura.');

            rooms[26] = new Room('un puente de mÃ¡rmol',
                'El puente es de mÃ¡rmol negro y estÃ¡ suspendido sobre un abismo sin fondo.');

            rooms[27] = new Room('la Antesala del Laberinto',
                'Usted puede sentir el laberinto esperÃ¡ndolo. El aire huele a miedo y a polvo antiguo.');

            rooms[28] = new Room('la cueva del Minotauro',
                'Una cueva enorme con paredes cubiertas de sangre seca. Hay huesos por todas partes.');

            rooms[29] = new Room('el SalÃ³n de los elegidos',
                'Las paredes estÃ¡n cubiertas con los nombres de aquellos que llegaron hasta aquÃ­.');

            rooms[30] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[31] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[32] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[33] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[34] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[35] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[36] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[37] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[38] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[39] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[40] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[41] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[42] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[43] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[44] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[45] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[46] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[47] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[48] = new Room('un pasillo del Laberinto',
                'Las paredes son idÃ©nticas en todas direcciones. Es imposible saber dÃ³nde estÃ¡.');

            rooms[49] = new Room('el JardÃ­n',
                'Se podrÃ­an construir varias ciudades en su interior.');

            gameState.rooms = rooms;

            // Populate rooms with items and links
            populateRooms(rooms);
        }

        function populateRooms(rooms) {
            // Room 0: Exterior
            rooms[0].insert(new Thing('Roble', 'EstÃ¡ completamente seco y lleno de mordiscos. Tiene las siguientes palabras talladas en el tronco: "Las palabras mÃ¡gicas para abrir la puerta son obvias."', 200));
            rooms[0].insert(new Thing('Maza', 'Es muy pesada.', 39));
            rooms[0].insert(new Thing('Pastel de cerezas', 'Â¿QuÃ© hace un pastel de cerezas en un lugar como este?', 2));
            rooms[0].insert(new Troll('Llamador de bronce', 'Parece de carne, y tiene forma de murciÃ©lago.', 'Cigarro',
                decodeLine(1),  // key[1]: Hay un nombre que vas a necesitar mucho: Rumpelstinskin.
                'Â¿Me puede regalar un cigarro?'));
            rooms[0].insert(new Linking('Puerta principal', 'Inmensa y oprimente.', decodeLine(2),  // key[2]: Abrete Sesamo
                'Su sombra desaparece lentamente al cruzar la puerta. Siente cÃ³mo el miedo se le enreda en los zapatos.', rooms[1]));
            rooms[0].insert(new OpenLink('TÃºnel', 'Parece muy largo.',
                'El olor de la carne descompuesta lo golpea. Usted siente ganas de vomitar.', rooms[3]));
            rooms[0].insert(new Hidden('Pared solitaria', 'Usted no puede imaginar con quÃ© motivo fue colocada ahÃ­.',
                decodeLine(3),  // key[3]: Ariete
                new DangerLink('Puerta secreta', 'Usted se pregunta a dÃ³nde conducirÃ¡, pero la oscuridad no le deja ver.', '',
                    'Usted atraviesa la puerta.', 'Antorcha', rooms[26])));

            // Room 1: SalÃ³n de recepciones
            rooms[1].insert(new Hidden('Monolito de mÃ¡rmol', 'Es muy oscuro, pero a usted le parece que hay algo vivo en su interior.',
                decodeLine(4),  // key[4]: Maza
                new Troll('Trebol', 'Tiene cinco hojas.', 'Vaso de agua',
                    decodeLine(5),  // key[5]: Busca a la doncella al lado del espejo...
                    'Dame agua, por favor...')));
            rooms[1].insert(new Thing('Retrato', 'Es de Hitchcock (un anacronismo). Usted recuerda instintivamente algunas pelÃ­culas que le erizaron la piel: Psicosis, VÃ©rtigo y Los treinta y nueve escalones.', 1));
            rooms[1].insert(new Linking('Puerta principal', 'Inmensa y oprimente.', decodeLine(2),  // key[2]: Abrete Sesamo
                'Usted se siente de regreso a la vida. Ha salido de La Fortaleza.', rooms[0]));
            rooms[1].insert(new Linking('Puerta negra', 'Es muy negra.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[2]));

            // Room 2: Sala de juegos
            rooms[2].insert(new Thing('Escoba', 'Es una escoba voladora.', 1));
            rooms[2].insert(new Thing('Hilo de Ariadna', 'Debe tener varios kilÃ³metros de largo.', 1));
            rooms[2].insert(new Thing('InscripciÃ³n', 'Dice: "Cuando hayas llegado casi al final, tendrÃ¡s que regresar, a no ser que hayas hablado con el murciÃ©lago."', 10));
            rooms[2].insert(new Linking('Puerta negra', 'Es muy negra.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[1]));
            rooms[2].insert(new Linking('Puerta azul', 'Esta puerta conduce al patio interior.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[3]));
            rooms[2].insert(new RiddleLink('Escalera', 'La escalera estÃ¡ detrÃ¡s de una puerta de cristal. Usted trata de ver cuÃ¡ntos escalones tiene, pero no puede.',
                'Â¿CuÃ¡ntos peldaÃ±os tiene la escalera?', decodeLine(6),  // key[6]: Treinta y nueve
                'Usted sube por la escalera. No se explica cÃ³mo, siendo tan larga, solo tiene ' + decodeLine(6) + ' escalones.', rooms[4]));

            // Room 3: Patio interior
            rooms[3].insert(new Thing('Balanza', 'La balanza tiene el plato en forma de mano. La aguja es muy delgada, hecha con varios bigotes de gato trenzados entre sÃ­.', 1));
            rooms[3].insert(new Linking('Puerta azul', 'Esta puerta conduce a la sala de juegos.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[2]));
            rooms[3].insert(new Linking('Puerta verde', 'Esta puerta conduce a la biblioteca.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[5]));
            rooms[3].insert(new Troll('Estatua de Atenea', 'Fue hecha por Fidias, siete aÃ±os despuÃ©s de su muerte. Le falta la lanza.', decodeLine(7),  // key[7]: Lanza
                decodeLine(8), 'Â¡Sal de mi presencia, estÃºpido mortal!'));  // key[8]: Para llegar a los pulmones...
            rooms[3].insert(new Troll('Estatua de Hermes', 'Desde el techo caen gotas continuamente sobre su cabeza.', decodeLine(9),  // key[9]: Paraguas
                decodeLine(10), 'La humedad me destruye.'));  // key[10]: En la biblioteca hay un libro...

            // Room 4: Cuarto de espejos
            rooms[4].insert(new Thing('Hueso de gato', 'Este es un hueso de gato (o de la imagen de un gato).', 1));
            rooms[4].insert(new Linking('Escalera', 'Usted trata de ver hasta dÃ³nde llega, pero no puede. EstÃ¡ detrÃ¡s de una puerta de cristal.', 'treinta y nueve',
                'Usted se sorprende: La escalera tiene ahora muchos escalones mÃ¡s.', rooms[2]));
            rooms[4].insert(new Hidden('Espejo opaco', 'En realidad, usted no tiene idea de por quÃ© es un espejo. Hay algo muy extraÃ±o en Ã©l.',
                decodeLine(11),  // key[11]: Hueso de gato
                new Linking('Puerta oculta', 'Parece formada por diminutos fragmentos de cristal.', '',
                'Su imagen regresa al atravesar la puerta.', rooms[13])));

            // Room 5: Biblioteca
            rooms[5].insert(new Thing('Vaso de agua', 'Por un momento cree ver un bote en el vaso.', 1));
            rooms[5].insert(new Thing('Candelabro', 'La llama en su extremo estÃ¡ inmÃ³vil, como si fuera de cera.', 1));
            rooms[5].insert(new Linking('Puerta verde', 'Esta puerta conduce al patio interior.', '',
                'Usted atraviesa la puerta sin dificultades.', rooms[3]));
            rooms[5].insert(new Linking('Libro', 'Es un libro normal.', '',
                'Â¡Usted ha atravesado el libro!', rooms[12]));
            rooms[5].insert(new Guard('CÃ­clope', 'Parece estar cuidando la puerta.', 'Â¡Arrrggghhhh! Â¡Me has matado!' + decodeLine(12), decodeLine(13)));  // keys[12,13]: Puedes pasar..., Maza
            rooms[5].insert(new Linking('Puerta', 'Es una puerta para gigantes.', decodeLine(14),  // key[14]: Nombus Rostomelaris
                'Usted se encuentra del otro lado de la puerta.', rooms[6]));

            // Room 6: Pasillo
            rooms[6].insert(new Thing('Antorcha', 'La llama parece bailar en su propia luz.', 1));
            rooms[6].insert(new Linking('Puerta', 'Es una puerta para gigantes.', decodeLine(14),  // key[14]: Nombus Rostomelaris
                'Usted se encuentra del otro lado de la puerta.', rooms[5]));
            rooms[6].insert(new Linking('Puerta vieja', 'Es la puerta de las habitaciones de una bruja.', '',
                'Usted ha entrado.', rooms[7]));
            rooms[6].insert(new Linking('Puerta roja', 'Es la puerta del guerrero.', '',
                'Usted se encuentra del otro lado de la puerta.', rooms[8]));
            rooms[6].insert(new Linking('Puerta prohibida', 'Esta puerta estÃ¡ prohibida para los humanos.', decodeLine(15),  // key[15]: Luz
                'Usted se encuentra del otro lado de la puerta.', rooms[9]));
            rooms[6].insert(new Linking('Puerta gris', 'Esta puerta conduce a la sala de las infusiones.', '',
                'Usted se encuentra del otro lado de la puerta.', rooms[14]));

            // Room 7: Alcoba de la bruja
            rooms[7].insert(new Thing('Polvo mÃ¡gico', 'Puede hacer invisible a cualquiera.', 1));
            rooms[7].insert(new Thing('PociÃ³n para crecer', 'Tiene un olor muy repugnante.', 5));
            rooms[7].insert(new Linking('Puerta vieja', 'Da al pasillo.', '', 'Usted ha salido.', rooms[6]));
            rooms[7].insert(new DangerLink('Escaparate', 'Tiene las puertas llenas de araÃ±azos.', '',
                decodeLine(16), 'Candelabro', rooms[13]));  // key[16]: Usted cae durante..., gentil con la doncella...
            rooms[7].insert(new Troll('Bruja', 'Parece tener mil aÃ±os.', 'Escoba',
                decodeLine(17),  // key[17]: Escucha bien, hijo...
                'TrÃ¡eme mi escoba y te darÃ© un consejo.'));

            // Room 8: Cuarto del guerrero
            rooms[8].insert(new Thing('Vendajes', 'EstÃ¡n manchados de sangre.', 3));
            rooms[8].insert(new Thing('Grabado', 'En el grabado estÃ¡ usted, hablando con una muchacha.', 3));
            rooms[8].insert(new Linking('Puerta roja', 'Da al pasillo.', '', 'Usted estÃ¡ en el pasillo nuevamente.', rooms[6]));
            rooms[8].insert(new Hidden('Cama', 'Es tan fuerte que solo con un hacha podrÃ­a romperla.',
                decodeLine(18),  // key[18]: Hacha
                new Linking('Puerta', 'EstÃ¡ en el suelo.', '', 'Usted entra a la armerÃ­a.', rooms[10])));

            // Room 9: Laboratorio
            rooms[9].insert(new Thing('Piedra filosofal', 'Usted es el primer humano en ver la quinta esencia.', 10));
            rooms[9].insert(new Thing('MÃ¡quina del tiempo', 'Es muy parecida a una mÃ¡quina de moler carne.', 3));
            rooms[9].insert(new Linking('Puerta prohibida', 'Esta puerta estÃ¡ prohibida para los humanos.', decodeLine(15),  // key[15]: Luz
                'Usted se encuentra en el otro lado de la puerta.', rooms[6]));
            rooms[9].insert(new Troll('HomÃºnculo', 'Parece que escapÃ³ de algÃºn frasco. Es tan pequeÃ±o que usted se arrodilla para verlo.', 'PociÃ³n para crecer',
                decodeLine(20), 'Â¡Quiero crecer!'));  // key[20]: Pocion para crecer

            // Room 10: Sala de Armas
            rooms[10].insert(new Thing('Espada', 'Es muy brillante.', 5));
            rooms[10].insert(new Thing('Lanza', 'EstÃ¡ hecha de piedra.', 10));
            rooms[10].insert(new Thing('Arco', 'Es el arco de Odiseo.', 5));
            rooms[10].insert(new Thing('Daga', 'Es afilada como la lengua de la serpiente bÃ­blica.', 3));
            rooms[10].insert(new Thing('Ariete', 'Demasiado grande y pesado.', 30));
            rooms[10].insert(new Thing('LÃ¡tigo', 'Parece una culebra.', 2));
            rooms[10].insert(new Linking('Puerta', 'EstÃ¡ en el techo.', '', 'Usted regresa al cuarto del guerrero.', rooms[8]));

            // Room 11: BaÃ±os de la Bestia
            rooms[11].insert(new Thing('Rosa', 'Es mÃ¡s hermosa que todas las doncellas que usted no ha visto.', 1));
            rooms[11].insert(new Thing('Espejo', 'Usted se ve a sÃ­ mismo entregÃ¡ndole unos polvos al Troll.', 20));
            rooms[11].insert(new Thing('InscripciÃ³n', 'Dice: Â¡Mate al Troll! Y no haga sus necesidades en el suelo.', 2));
            rooms[11].insert(new Linking('Puerta verde', 'Conduce al jardÃ­n.', '', 'Usted entra al jardÃ­n.', rooms[12]));
            rooms[11].insert(new Troll('Troll', 'EstÃ¡ mirÃ¡ndose en un espejo. Tiene una figura tan repulsiva que usted aparta la vista.', 'Polvo mÃ¡gico',
                decodeLine(22), 'No me mates, por favor. Haz que nadie pueda ver mi fealdad.'));  // key[22]: Polvo magico

            // Room 12: JardÃ­n
            rooms[12].insert(new Thing('Cedro', 'Le faltan algunas ramas. Al parecer, alguien las cortÃ³ para hacerse una cama.', 999));
            rooms[12].insert(new Thing('InscripciÃ³n', 'Es un buen lugar para instalar una tienda de campaÃ±a Â¿no cree?', 1));
            rooms[12].insert(new Linking('Puerta verde', 'Conduce a los baÃ±os de la Bestia.', '',
                'Usted sale del jardÃ­n.', rooms[11]));
            rooms[12].insert(new Linking('Puerta azul', 'Debe haber algo hermoso detrÃ¡s de esta puerta.', '',
                'Usted sale del jardÃ­n.', rooms[13]));
            rooms[12].insert(new Linking('Puerta amarilla', 'Conduce a la sala de infusiones.', '',
                'Usted sale del jardÃ­n.', rooms[14]));
            rooms[12].insert(new Linking('Puerta de hierro', 'Conduce a los calabozos.', '', 'Usted entra a los calabozos.', rooms[15]));
            rooms[12].insert(new Linking('Puerta de madera', 'Conduce al almacÃ©n.', '',
                'Usted sale del jardÃ­n.', rooms[22]));

            // Room 13: Alcoba de la doncella
            rooms[13].insert(new Thing('Cuadro', 'EstÃ¡ pintado de negro, infinitamente negro y contundente.', 10));
            rooms[13].insert(new Thing('CorazÃ³n de unicornio', 'AÃºn late.', 1));
            rooms[13].insert(new Linking('Puerta azul', 'Debe haber algo hermoso detrÃ¡s de esta puerta.', '',
                'Usted sale al jardÃ­n.', rooms[12]));
            rooms[13].insert(new Linking('Puerta oculta', 'Parece formada por diminutos fragmentos de cristal.', '',
                'Su imagen regresa al atravesar la puerta.', rooms[4]));
            rooms[13].insert(new Linking('Escaparate', 'Las puertas son doradas.', '',
                'Usted sube durante varios minutos hasta llegar al escaparate de la bruja.', rooms[7]));
            rooms[13].insert(new Troll('Doncella', 'Nunca antes habÃ­a contemplado tanta hermosura. Usted estÃ¡ como hipnotizado.', decodeLine(24),  // key[24]: Rumpelstinskin
                decodeLine(25), 'Â¡QuÃ© brusco! Un caballero debe dirigirse a una dama de otra forma.'));  // key[25]: Rosa

            // Room 14: Sala de infusiones
            rooms[14].insert(new Thing('Taza de cafÃ©', 'Humea.', 1));
            rooms[14].insert(new Thing('Cigarro', 'EstÃ¡ encendido.', 1));
            rooms[14].insert(new Linking('Puerta gris', 'Da al pasillo.', '',
                'Usted se encuentra del otro lado de la puerta.', rooms[6]));
            rooms[14].insert(new Linking('Puerta amarilla', 'Conduce al jardÃ­n.', '', 'Usted sale al jardÃ­n.', rooms[12]));
            rooms[14].insert(new Guard('ArpÃ­a', 'EstÃ¡ desayunando. Usted recuerda a su suegra sin darse cuenta.',
                decodeLine(26), decodeLine(27)));  // keys[26,27]: La Ãºltima habitaciÃ³n..., Imnus humiscuol...

            // Room 15: Calabozos
            rooms[15].insert(new Thing('Paraguas', 'EstÃ¡ cerrado.', 2));
            rooms[15].insert(new Thing('TalismÃ¡n de aire', 'EstÃ¡ hecho de cinco vientos amarrados con un cordÃ³n negro.', 1));
            rooms[15].insert(new Linking('Puerta de hierro', 'Conduce al jardÃ­n.', '', 'Usted sale al jardÃ­n.', rooms[12]));
            rooms[15].insert(new Troll('Esqueleto', 'Debe tener varios siglos.', 'Taza de cafÃ©',
                decodeLine(29), 'Dame algo para calentarme la barriga, por favor.'));  // key[29]: Taza de cafe

            // Room 16: Boca
            rooms[16].insert(new Linking('Puerta triangular', 'Tiene forma de un triÃ¡ngulo de siete lados.', '',
                'Usted sale de la boca de la Bestia.', rooms[24]));
            rooms[16].insert(new OpenLink('Garganta', 'Es roja y carnosa.',
                'Usted atraviesa por la garganta de la Bestia.', rooms[17]));

            // Room 17: Interior
            rooms[17].insert(new Thing('InscripciÃ³n', 'No continÃºe si no estÃ¡ protegido.', 10));
            rooms[17].insert(new Linking('Garganta', 'Es roja y carnosa.', '',
                'Usted atraviesa por la garganta de la Bestia.', rooms[16]));
            rooms[17].insert(new DangerLink('TrÃ¡quea', 'Luce igual que en los libros de biologÃ­a que habÃ­a en su escuela.', '',
                'Usted atraviesa por la trÃ¡quea de la Bestia.', decodeLine(30), rooms[18]));  // key[30]: Talisman de aire
            rooms[17].insert(new DangerLink('EsÃ³fago', 'Parece un tÃºnel.', '',
                'Usted atraviesa por el esÃ³fago de la Bestia.', decodeLine(31), rooms[19]));  // key[31]: Pastel de cerezas
            rooms[17].insert(new DangerLink('Arteria principal', 'Conduce al corazÃ³n seguramente.', '',
                'Usted atraviesa por la arteria principal de la Bestia.', 'CorazÃ³n de unicornio', rooms[20]));

            // Room 18: Pulmones
            rooms[18].insert(new Linking('TrÃ¡quea', 'Luce igual que en los libros de biologÃ­a que habÃ­a en su escuela.', '',
                'Usted atraviesa por la trÃ¡quea de la Bestia.', rooms[17]));
            rooms[18].insert(new Guard('Centro de los pulmones', 'De aquÃ­ surge la vida de los pulmones.',
                decodeLine(35), decodeLine(32)));  // keys[35,32]: message, weapon

            // Room 19: EstÃ³mago
            rooms[19].insert(new Linking('EsÃ³fago', 'Parece un tÃºnel.', '',
                'Usted atraviesa por el esÃ³fago de la Bestia.', rooms[17]));
            rooms[19].insert(new Guard('Centro del estomago', 'De aquÃ­ surge la vida del estÃ³mago.',
                'Â¡Usted ha matado al centro del estÃ³mago!', decodeLine(33)));  // key[33]: weapon

            // Room 20: CorazÃ³n
            rooms[20].insert(new Linking('Arteria principal', 'Conduce al corazÃ³n seguramente.', '',
                'Usted atraviesa por la arteria principal de la Bestia.', rooms[17]));
            rooms[20].insert(new Guard('Centro del corazon', 'De aquÃ­ surge la vida del corazÃ³n.',
                decodeLine(37), decodeLine(34)));  // keys[37,34]: message, weapon

            // Room 21: Cerebro
            rooms[21].insert(new Thing('InscripciÃ³n', decodeLine(39), 10));  // key[39]: Â¿Mataste al Troll?
            rooms[21].insert(new Guard('Centro del cerebro', 'Â¡Usa la antorcha!', 'XVBCZXV XBVCZX BVZXC!!!!! ',
                decodeLine(38)));  // key[38]: weapon

            // Room 22: AlmacÃ©n
            rooms[22].insert(new Thing('Hacha', 'EstÃ¡ muy afilada.', 10));
            rooms[22].insert(new Linking('Puerta de madera', 'Conduce al jardÃ­n.', '',
                'Usted sale del almacÃ©n.', rooms[12]));
            rooms[22].insert(new Linking('Puerta verde', 'Usted presiente que hay algo muy grande detrÃ¡s de ella.', '',
                'Usted entra al pÃ¡ramo.', rooms[23]));
            rooms[22].insert(new Troll('RatÃ³n', 'Tiene puesto un delantal de alquimista.', decodeLine(40),  // key[40]: Piedra filosofal
                decodeLine(41), 'No tengo tiempo para atenderte. Llevo medio siglo buscando la quinta esencia.'));
   
            // Room 23: PÃ¡ramo
            rooms[23].insert(new Linking('Puerta verde', 'Conduce al almacÃ©n.', '',
                'Usted sale del pÃ¡ramo.', rooms[22]));
            rooms[23].insert(new Linking('Puerta de cristal', 'Es muy delgada.', decodeLine(42),  // key[42]: Cuidado con el tÃºnel y la puerta de tela...
                'Usted sale del pÃ¡ramo.', rooms[24]));
            rooms[23].insert(new DangerLink('TÃºnel', 'Parece mÃ¡s acogedor que el tÃºnel del exterior de la fortaleza.', '',
                'Usted atraviesa el tÃºnel.', decodeLine(43), rooms[23]));  // key[43]: Agua - trap door loops back
            rooms[23].insert(new OpenLink('Pozo', 'Es muy profundo.',
                'Usted cae vertiginosamente por el pozo y, antes de que pueda darse cuenta, estÃ¡ en el exterior de la fortaleza.', rooms[0]));
            rooms[23].insert(new Guard('Lobo', 'Es del tamaÃ±o de un ternero. La Ãºnica forma de pasar por la puerta de cristal es matÃ¡ndolo.', decodeLine(44), 'Latigo'));  // key[44]: confession

            // Room 24: SalÃ³n de cristal
            rooms[24].insert(new Linking('Puerta de cristal', 'Es muy delgada.', decodeLine(42),  // key[42]: Cuidado con el tÃºnel y la puerta de tela...
                'Usted sale al pÃ¡ramo.', rooms[23]));
            rooms[24].insert(new Linking('Puerta de tela', 'Es una puerta aparentemente normal, pero de tela. Algo le preocupa sobre esta puerta.', '',
                'Usted sale del salÃ³n de cristal.', rooms[25])); // Leads to jail
            rooms[24].insert(new RiddleLink('Puerta triangular', 'Tiene forma de un triÃ¡ngulo de siete lados.',
                'Â¿CuÃ¡l es el nombre del duende?', decodeLine(23),  // key[23]: Rumpelstinskin
                'Usted entra a la boca de la Bestia.', rooms[16]));
            rooms[24].insert(new Troll('Bailarina', 'Es muy joven.', 'MÃ¡quina del tiempo',
                decodeLine(47), 'Quiero ser joven para siempre.'));  // key[47]: Maquina del tiempo

            // Room 25: Celda (Prison cell)
            rooms[25].insert(new Thing('InscripciÃ³n', 'Dice que usted pasarÃ¡ en esta celda el resto de sus dÃ­as.', 41));  // succ(LWeight) = 41

            // Room 26: Puente de mÃ¡rmol (Marble bridge)
            rooms[26].insert(new Troll('AraÃ±a', 'Es un poco mayor que usted, pero ya no puede producir hilo.', 'Hilo de Ariadna',
                'Busca al Minotauro y mÃ¡talo con la espada.', 'Â¡Pssssssss!'));
            rooms[26].insert(new Thing('Martillo', 'Tiene dos mangos y tres cabezas.', 2));
            rooms[26].insert(new DangerLink('Puerta secreta', 'Conduce al exterior de la fortaleza.', '',
                'Usted atraviesa la puerta.', 'Antorcha', rooms[0]));
            rooms[26].insert(new Hidden('Estatua de SatanÃ¡s', 'Es infinitamente negra.',
                'Cuadro', new Linking('Puerta oculta', 'Conduce a la antesala del laberinto.', '',
                    'Usted atraviesa la puerta.', rooms[27])));
            rooms[26].insert(new DangerLink2('Puerta', 'Conduce a la antesala del Laberinto.', '',
                'Usted atraviesa la puerta.', 'Espada', rooms[27]));

            // Room 27: Antesala del Laberinto
            rooms[27].insert(new Linking('Puerta', 'Conduce al puente.', '', 'Usted atraviesa la puerta.', rooms[26]));
            rooms[27].insert(new Troll('Crunch', 'Es muy similar a una boca con patas.', 'Pastel de cerezas',
                'Las secuencia que necesitas es 1, 2, 3, 1, 2, 3, 1', 'Â¡QuÃ© hambre!'));
            rooms[27].insert(new Hidden('Columna de Cristal', 'Es muy alta.',
                'Antorcha 3',
                new Hidden('Puerta de madera', 'Parece muy frÃ¡gil, tiene dos picaportes y tres bisagras.', 'Martillo',
                    new Linking('Puerta negra', 'Conduce al JardÃ­n', '',
                        'Usted entra al JardÃ­n.', rooms[49]))));
            rooms[27].insert(new OpenLink('Puerta verde', 'Conduce al Laberinto.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[27].insert(new Troll('DÃ©dalo', 'Parece haber sido herido por el cuerno de un toro gigante.', 'Vendajes',
                'Solo el hierro te protegerÃ¡ contra las flores.', 'Me muero...'));

            // Room 28: Minotauro
            rooms[28].insert(new OpenLink('Puerta', 'Conduce al Laberinto.', 'Usted atraviesa la puerta.', rooms[46]));
            rooms[28].insert(new Thing('Antorcha 1', 'Es muy brillante.', 2));
            rooms[28].insert(new Thing('Antorcha 2', 'Es muy brillante.', 2));
            rooms[28].insert(new Thing('Antorcha 3', 'Es muy brillante.', 2));
            rooms[28].insert(new Thing('Antorcha 4', 'Es muy brillante.', 2));
            rooms[28].insert(new Thing('Antorcha 5', 'Es muy brillante.', 2));
            rooms[28].insert(new Thing('Antorcha 6', 'EstÃ¡ apagada.', 2));
            rooms[28].insert(new Thing('Antorcha 7', 'Es muy brillante.', 2));
            rooms[28].insert(new Guard('Minotauro', 'EstÃ¡ sentado en un enorme trono de rocas.',
                'Â¡Me has matado! Coge la antorcha del nÃºmero divino y rompe la columna de cristal.', 'Espada'));

            // Room 29: SalÃ³n de los elegidos
            rooms[29].insert(new RiddleLink('Puerta dorada', 'Es de oro macizo.',
                'Invente un alfabeto (el mayor que pueda) con el que no pueda crearse a la Bestia.',
                'cdfghjklmnopqruvwxyz',
                'Â¡Usted ha entrado al Cerebro de la Bestia!', rooms[21]));

            // Rooms 30-48: Labyrinth maze (all "un pasillo del Laberinto")
            // Room 30 (Pascal room 31)
            rooms[30].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[31]));
            rooms[30].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[27]));
            rooms[30].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[37]));

            // Room 31 (Pascal room 32)
            rooms[31].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[31].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[32]));
            rooms[31].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[43]));

            // Room 32 (Pascal room 33)
            rooms[32].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[25]));
            rooms[32].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[31]));
            rooms[32].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[33]));

            // Room 33 (Pascal room 34)
            rooms[33].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[34]));
            rooms[33].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[40]));
            rooms[33].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[32]));

            // Room 34 (Pascal room 35)
            rooms[34].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[33]));
            rooms[34].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[35]));
            rooms[34].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[45]));

            // Room 35 (Pascal room 36)
            rooms[35].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[48]));
            rooms[35].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[34]));
            rooms[35].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[36]));

            // Room 36 (Pascal room 37)
            rooms[36].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[28]));
            rooms[36].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[36].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[35]));

            // Room 37 (Pascal room 38)
            rooms[37].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[25]));
            rooms[37].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[38]));
            rooms[37].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));

            // Room 38 (Pascal room 39)
            rooms[38].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[38].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[37]));
            rooms[38].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[39]));

            // Room 39 (Pascal room 40)
            rooms[39].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[39].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[25]));
            rooms[39].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[38]));

            // Room 40 (Pascal room 41)
            rooms[40].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[32]));
            rooms[40].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[33]));
            rooms[40].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[41]));

            // Room 41 (Pascal room 42)
            rooms[41].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[31]));
            rooms[41].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[42]));
            rooms[41].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[40]));

            // Room 42 (Pascal room 43)
            rooms[42].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[25]));
            rooms[42].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[41]));
            rooms[42].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[43]));

            // Room 43 (Pascal room 44)
            rooms[43].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[44]));
            rooms[43].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[31]));
            rooms[43].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));

            // Room 44 (Pascal room 45)
            rooms[44].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[43]));
            rooms[44].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[31]));
            rooms[44].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));

            // Room 45 (Pascal room 46)
            rooms[45].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[46]));
            rooms[45].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[32]));
            rooms[45].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[34]));

            // Room 46 (Pascal room 47)
            rooms[46].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[45]));
            rooms[46].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[33]));
            rooms[46].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[47]));

            // Room 47 (Pascal room 48)
            rooms[47].insert(new OpenLink('Puerta 1', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[30]));
            rooms[47].insert(new OpenLink('Puerta 2', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[48]));
            rooms[47].insert(new OpenLink('Puerta 3', 'Es idÃ©ntica a las otras dos.', 'Usted atraviesa la puerta.', rooms[46]));

            // Room 48 (Pascal room 49) - Exit from labyrinth
            rooms[48].insert(new OpenLink('Salida', 'Conduce a la entrada del laberinto.',
                'Usted regresa a la entrada del Laberinto.', rooms[27]));

            // Room 49 (Pascal room 50) - False Garden
            rooms[49].insert(new Thing('InscripciÃ³n', 'Â¡Cuidado! Este no es el JardÃ­n verdadero.', 1));
            rooms[49].insert(new Thing('Cedro', 'Le faltan algunas ramas. Al parecer, alguien las cortÃ³ para hacerse una cama.', 41));  // succ(LWeight) = 41
            rooms[49].insert(new OpenLink('Puerta verde', 'Conduce a los baÃ±os de la Bestia.',
                'Usted sale del jardÃ­n.', rooms[25]));
            rooms[49].insert(new OpenLink('Puerta azul', 'Debe haber algo hemoso detrÃ¡s de esta puerta.',
                'Usted sale del jardÃ­n.', rooms[25]));
            rooms[49].insert(new OpenLink('Puerta amarilla', 'Conduce a la sala de infusiones.',
                'Usted sale del jardÃ­n.', rooms[25]));
            rooms[49].insert(new RiddleLink('Puerta de hierro', 'Conduce los calabozos.',
                'Â¿CuÃ¡ntas antorchas iluminan al Minotauro?',
                'Seis', 'Usted entra al salÃ³n de los elegidos.', rooms[29]));
            rooms[49].insert(new OpenLink('Puerta de madera', 'Conduce al almacÃ©n.', 'Usted sale del jardÃ­n.', rooms[25]));
        }

        // ==================== UI FUNCTIONS ====================

        function printLine(text, className = '') {
            // Skip empty strings
            if (text === '') return;

            const output = document.getElementById('output');
            const line = document.createElement('div');
            line.className = 'output-line' + (className ? ' ' + className : '');

            // Wrap text in a reveal container
            const textReveal = document.createElement('span');
            textReveal.className = 'text-reveal';
            textReveal.textContent = text;

            // Create mask overlay
            const mask = document.createElement('div');
            mask.className = 'text-mask';

            // Create scanline
            const scanline = document.createElement('div');
            scanline.className = 'text-scanline';
            scanline.style.left = '0px';

            // Create dot
            const dot = document.createElement('div');
            dot.className = 'text-scanline-dot';
            scanline.appendChild(dot);

            textReveal.appendChild(mask);
            textReveal.appendChild(scanline);
            line.appendChild(textReveal);
            output.appendChild(line);

            // Animate the scanline - keep it fast and skip for very long text
            const textWidth = textReveal.offsetWidth;

            // Skip animation for very long text to keep things snappy
            if (text.length > 100) {
                // Instant reveal for long text
                textReveal.removeChild(mask);
                textReveal.removeChild(scanline);
            } else {
                // Short, fast animation for shorter text
                const duration = Math.max(80, Math.min(200, text.length * 3));
                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Linear motion for text
                    const currentX = progress * textWidth;
                    scanline.style.left = currentX + 'px';

                    // Clip the mask to reveal text progressively
                    mask.style.clipPath = `inset(0 0 0 ${currentX}px)`;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation complete, clean up
                        textReveal.removeChild(mask);
                        textReveal.removeChild(scanline);
                    }
                }

                requestAnimationFrame(animate);
            }

            // Scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function updateInventory() {
            // No inventory UI - this function does nothing
        }

        // ==================== AUTOCOMPLETE SYSTEM ====================

        const autocompleteState = {
            suggestions: [],
            currentIndex: -1,
            originalInput: ''
        };

        // Define all command verbs
        const commandVerbs = [
            'ir', 'atravesar', 'entrar', 'cruzar', 'pasar',
            'tomar', 'coger', 'recoger', 'agarrar',
            'dejar', 'soltar', 'tirar',
            'ver', 'examinar', 'mirar',
            'abrir', 'romper', 'matar', 'atacar', 'destruir',
            'dar', 'hablar', 'preguntar', 'preguntarle',
            'pesar', 'inventario', 'ayuda', 'guardar', 'cargar',
            'partidas', 'borrar', 'salir', 'quit'
        ];

        // Multi-word connectors
        const connectors = ['con', 'a'];

        function getAvailableObjects() {
            const objects = [];

            // Room objects first
            if (gameState.player && gameState.player.curr) {
                gameState.player.curr.items.forEach(item => {
                    objects.push({ name: item.name, location: 'room' });
                });
            }

            // Inventory objects
            if (gameState.player && gameState.player.bag) {
                gameState.player.bag.items.forEach(item => {
                    objects.push({ name: item.name, location: 'inventory' });
                });
            }

            return objects;
        }

        function getSuggestions(input) {
            if (!input) return [];

            const words = input.toLowerCase().split(' ');
            const lastWord = words[words.length - 1];

            // Determine what we're autocompleting
            // If there's only one word and no trailing space, autocomplete verb
            if (words.length === 1 && !input.endsWith(' ')) {
                // Autocomplete command verb
                return commandVerbs
                    .filter(cmd => cmd.startsWith(lastWord) && cmd !== lastWord)
                    .map(cmd => cmd);
            } else {
                // Check if we need a connector
                const verb = words[0];
                const needsConnector = ['abrir', 'romper', 'matar', 'atacar', 'destruir'].includes(verb) ||
                                     (verb === 'dar' && !input.toLowerCase().includes(' a '));

                if (needsConnector) {
                    // Check if 'con' or 'a' should be suggested
                    const hasConnector = input.toLowerCase().includes(' con ') || input.toLowerCase().includes(' a ');

                    if (!hasConnector) {
                        // Get text after the command
                        const afterCommand = words.slice(1).join(' ').trim();

                        // If there's something typed after the command and it ends with a space,
                        // suggest the connector
                        if (afterCommand !== '' && input.endsWith(' ')) {
                            const connector = verb === 'dar' ? 'a' : 'con';
                            return [connector];
                        } else if (afterCommand !== '') {
                            // Check if user is typing the connector
                            // Get everything before the last word
                            const beforeLastWord = words.slice(1, -1).join(' ').trim();
                            const lastWord = words[words.length - 1].toLowerCase();
                            const connector = verb === 'dar' ? 'a' : 'con';

                            // Check if we have an object name (beforeLastWord has content) and last word starts connector
                            if (beforeLastWord !== '' && connector.startsWith(lastWord) && lastWord !== '' && connector !== lastWord) {
                                return [connector];
                            }
                        }
                    }
                }

                // Autocomplete object names
                let objects = getAvailableObjects();

                // Get what's been typed after the command
                // If there's a connector, look for text after the connector
                let afterCommand = words.slice(1).join(' ').trim();

                const connectorIndex = input.toLowerCase().lastIndexOf(' con ');
                const aIndex = input.toLowerCase().lastIndexOf(' a ');

                if (connectorIndex !== -1) {
                    // There's ' con ', get text after it
                    afterCommand = input.substring(connectorIndex + 5).trim(); // +5 for ' con '

                    // For 'abrir' command, don't suggest objects after 'con' (magic words, not objects)
                    if (verb === 'abrir') {
                        return [];
                    }
                } else if (aIndex !== -1) {
                    // There's ' a ', get text after it (the recipient for 'dar')
                    afterCommand = input.substring(aIndex + 3).trim(); // +3 for ' a '
                    // After 'a', suggest room objects first, then inventory (recipients can be anywhere)
                } else {
                    // Before any connector - filter objects based on command semantics

                    // Commands that only work with inventory items (things you must be carrying)
                    if (['dar', 'dejar', 'soltar', 'tirar', 'pesar'].includes(verb)) {
                        objects = objects.filter(obj => obj.location === 'inventory');
                    }
                    // Commands that only work with room objects (things you must take from the room)
                    else if (['tomar', 'coger', 'recoger', 'agarrar'].includes(verb)) {
                        objects = objects.filter(obj => obj.location === 'room');
                    }
                    // All other commands work with all objects (room + inventory)
                    // This includes: ver, examinar, mirar, abrir, romper, matar, atacar, destruir,
                    // ir, atravesar, entrar, cruzar, pasar, hablar, preguntar, preguntarle
                }

                // Find objects that match
                return objects
                    .filter(obj => {
                        const objName = obj.name.toLowerCase();
                        return objName.startsWith(afterCommand.toLowerCase()) || afterCommand === '';
                    })
                    .map(obj => obj.name);
            }
        }

        function updateAutocompleteDisplay(input) {
            const value = input.value;
            autocompleteState.suggestions = getSuggestions(value);
            autocompleteState.currentIndex = -1;
            autocompleteState.originalInput = value;

            // Clear any previous suggestion display
            const existing = input.parentElement.querySelector('.autocomplete-suggestion');
            if (existing) existing.remove();

            if (autocompleteState.suggestions.length > 0) {
                showSuggestion(input, autocompleteState.suggestions[0]);
            }
        }

        function showSuggestion(input, suggestion) {
            // Remove existing
            const existing = input.parentElement.querySelector('.autocomplete-suggestion');
            if (existing) existing.remove();

            const value = input.value;

            // Calculate what part of the suggestion hasn't been typed yet
            let completionPart = '';

            const words = value.split(' ');

            // Check if we're completing a verb (single word, no space at end)
            if (words.length === 1 && !value.endsWith(' ')) {
                // Completing verb
                const typed = words[0];
                if (suggestion.toLowerCase().startsWith(typed.toLowerCase())) {
                    completionPart = suggestion.substring(typed.length);
                } else {
                    return;
                }
            } else if (suggestion === 'con' || suggestion === 'a') {
                // Completing connector
                if (value.endsWith(' ')) {
                    // Show full connector with space: invisible="abrir puerta", visible=" con"
                    completionPart = ' ' + suggestion;
                } else {
                    // User is typing the connector (e.g., "abrir puerta principal c")
                    const lastWord = words[words.length - 1].toLowerCase();
                    if (suggestion.startsWith(lastWord) && lastWord !== '') {
                        // Show only the remaining part: invisible="abrir puerta c", visible="on"
                        completionPart = suggestion.substring(lastWord.length);
                    } else {
                        return;
                    }
                }
            } else {
                // Completing object name (after the verb)
                const afterCommand = words.slice(1).join(' ').trim();

                if (afterCommand === '') {
                    // Nothing typed after command, show full suggestion
                    // If value ends with space, add space before suggestion
                    completionPart = value.endsWith(' ') ? ' ' + suggestion : suggestion;
                } else {
                    // User has typed part of the object name
                    if (suggestion.toLowerCase().startsWith(afterCommand.toLowerCase())) {
                        // Show the remaining part of the suggestion
                        completionPart = suggestion.substring(afterCommand.length);
                    } else {
                        return; // No match
                    }
                }
            }

            if (!completionPart) return; // Nothing to show

            // Create suggestion display
            const suggestionSpan = document.createElement('span');
            suggestionSpan.className = 'autocomplete-suggestion';

            // Remove trailing space from value to avoid double spacing
            let textToMeasure = value;
            if (value.endsWith(' ')) {
                textToMeasure = value.slice(0, -1);
            }

            // Just show the completion part
            suggestionSpan.textContent = completionPart;

            // Measure the width of the typed text to position the completion correctly
            const measureSpan = document.createElement('span');
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.position = 'absolute';
            measureSpan.style.whiteSpace = 'pre';
            measureSpan.style.font = window.getComputedStyle(input).font;
            measureSpan.textContent = textToMeasure;
            document.body.appendChild(measureSpan);
            const textWidth = measureSpan.offsetWidth;
            document.body.removeChild(measureSpan);

            suggestionSpan.style.position = 'absolute';
            // Position after the typed text
            suggestionSpan.style.left = (input.offsetLeft + 22 - input.scrollLeft + textWidth) + 'px';
            suggestionSpan.style.top = (input.offsetTop + 10) + 'px';
            suggestionSpan.style.pointerEvents = 'none';
            suggestionSpan.style.color = 'rgba(57, 255, 20, 0.35)';
            suggestionSpan.style.whiteSpace = 'pre';

            input.parentElement.appendChild(suggestionSpan);
        }

        function cycleSuggestion(direction) {
            if (autocompleteState.suggestions.length === 0) return;

            autocompleteState.currentIndex += direction;

            if (autocompleteState.currentIndex < 0) {
                autocompleteState.currentIndex = autocompleteState.suggestions.length - 1;
            } else if (autocompleteState.currentIndex >= autocompleteState.suggestions.length) {
                autocompleteState.currentIndex = 0;
            }

            const input = document.getElementById('input');
            const suggestion = autocompleteState.suggestions[autocompleteState.currentIndex];
            showSuggestion(input, suggestion);
        }

        function acceptSuggestion() {
            if (autocompleteState.suggestions.length === 0) return false;

            const input = document.getElementById('input');
            const value = input.value;
            const suggestion = autocompleteState.suggestions[
                autocompleteState.currentIndex === -1 ? 0 : autocompleteState.currentIndex
            ];

            const words = value.split(' ');

            // Check if we're completing a verb or an object
            if (words.length === 1 || (words.length === 2 && value.endsWith(' '))) {
                // Completing verb or first word after verb
                if (value.endsWith(' ')) {
                    // After space, append the suggestion
                    input.value = value + suggestion + ' ';
                } else {
                    // Replace the current word
                    input.value = suggestion + ' ';
                }
            } else {
                // Completing multi-word object name
                const afterCommand = words.slice(1).join(' ').trim();

                if (afterCommand === '') {
                    // Nothing typed after verb yet
                    input.value = words[0] + ' ' + suggestion + ' ';
                } else if (suggestion.toLowerCase().startsWith(afterCommand.toLowerCase())) {
                    // Append only the remaining part
                    input.value = value + suggestion.substring(afterCommand.length) + ' ';
                } else {
                    // Replace last word
                    words[words.length - 1] = suggestion;
                    input.value = words.join(' ') + ' ';
                }
            }

            // Clear autocomplete
            const existing = input.parentElement.querySelector('.autocomplete-suggestion');
            if (existing) existing.remove();
            autocompleteState.suggestions = [];
            autocompleteState.currentIndex = -1;

            // Update for next part
            updateAutocompleteDisplay(input);

            return true;
        }

        // ==================== COMMAND PROCESSING ====================

        // Execute a command (used by both processCommand and load replay)
        function executeCommand(command) {
            // Parse command - keep original case for passwords/keys
            const words = command.split(' ');
            const verb = words[0].toLowerCase();
            const rest = words.slice(1).join(' ');

            // Command handling
            switch(verb) {
                case 'ayuda':
                case 'help':
                    printLine('Comandos disponibles:');
                    printLine('- ir/atravesar [lugar]: ir a un lugar');
                    printLine('- tomar/coger [objeto]: tomar un objeto');
                    printLine('- dejar/soltar [objeto]: dejar un objeto');
                    printLine('- dejar todo: dejar todos los objetos');
                    printLine('- mirar: mirar alrededor');
                    printLine('- ver/examinar [objeto]: examinar un objeto');
                    printLine('- inventario/i: ver tu inventario');
                    printLine('- abrir [puerta] con [palabra]: abrir una puerta');
                    printLine('- romper [objeto] con [arma]: romper algo');
                    printLine('- matar/atacar [objetivo] con [arma]: atacar algo');
                    printLine('- dar [objeto] a [quien]: dar un objeto');
                    printLine('- hablar/preguntar [quien]: hablar con alguien');
                    printLine('- pesar [objeto]: pesar un objeto');
                    printLine('- guardar [nombre]: guardar partida');
                    printLine('- cargar [nombre]: cargar partida');
                    printLine('- partidas: listar partidas guardadas');
                    printLine('- borrar [nombre]: borrar partida guardada');
                    printLine('- salir/quit: abandonar el juego');
                    break;

                case 'inventario':
                case 'i':
                case 'inv':
                    gameState.player.inventary();
                    break;

                case 'mirar':
                    // If object specified, act like "ver", otherwise like "look"
                    if (rest && rest.trim()) {
                        gameState.player.see(rest);
                    } else {
                        gameState.player.look(true); // Clear history when explicitly looking
                    }
                    break;

                case 'look':
                    gameState.player.look(true); // Clear history when explicitly looking
                    break;

                case 'ver':
                case 'examinar':
                case 'v':
                    gameState.player.see(rest);
                    break;

                case 'tomar':
                case 'coger':
                case 'recoger':
                case 'agarrar':
                    gameState.player.take(rest);
                    break;

                case 'dejar':
                case 'soltar':
                case 'tirar':
                    if (rest === 'todo') {
                        gameState.player.leaveAll();
                    } else {
                        gameState.player.leave(rest);
                    }
                    break;

                case 'ir':
                case 'atravesar':
                case 'entrar':
                case 'cruzar':
                case 'pasar':
                    gameState.player.walkT(rest);
                    break;

                case 'abrir':
                    const parts = command.split(' con ');
                    const door = parts[0].replace(/abrir /i, '').trim();
                    const key = parts[1] ? parts[1].trim() : '';
                    gameState.player.openD(door, key);
                    break;

                case 'romper':
                    const breakParts = command.split(' con ');
                    const what = breakParts[0].replace(/romper /i, '').trim();
                    const weapon = breakParts[1] ? breakParts[1].trim() : '';
                    gameState.player.breakItem(what, weapon);
                    break;

                case 'matar':
                case 'atacar':
                case 'destruir':
                    const killParts = command.split(' con ');
                    const target = killParts[0].replace(/^(matar|atacar|destruir) /i, '').trim();
                    const weap = killParts[1] ? killParts[1].trim() : '';
                    gameState.player.kill(target, weap);
                    break;

                case 'dar':
                    const giveParts = command.split(' a ');
                    const gift = giveParts[0].replace(/dar /i, '').trim();
                    const recipient = giveParts[1] ? giveParts[1].trim() : '';
                    gameState.player.give(gift, recipient);
                    break;

                case 'hablar':
                case 'preguntar':
                case 'preguntarle':
                    gameState.player.ask(rest);
                    break;

                case 'pesar':
                    gameState.player.weigh(rest);
                    break;

                case 'guardar':
                case 'save':
                    if (!rest) {
                        showSaves();
                        printLine('');
                        printLine('Escribe: guardar [nombre] para guardar tu juego', 'system');
                    } else {
                        saveGame(rest);
                    }
                    break;

                case 'cargar':
                case 'load':
                    if (!rest) {
                        showSaves();
                        printLine('');
                        printLine('Escribe: cargar [nombre] para cargar tu juego', 'system');
                    } else {
                        loadGame(rest);
                    }
                    break;

                case 'partidas':
                case 'saves':
                case 'listar':
                case 'juegos':
                    showSaves();
                    break;

                case 'borrar':
                case 'eliminar':
                case 'delete':
                    if (!rest) {
                        showSaves();
                        printLine('');
                        printLine('Escribe: borrar [nombre] para eliminar un juego', 'system');
                    } else {
                        deleteSave(rest);
                    }
                    break;

                case 'salir':
                case 'quit':
                case 'morir':
                    printLine('Su entierro se efectuarÃ¡ el prÃ³ximo domingo a las 3:00 am. EstÃ¡ invitado.', 'system');
                    gameState.player.die('');
                    gameState.gameOver = true;
                    break;

                default:
                    printLine('No entiendo ese comando. Escribe "ayuda" para ver comandos disponibles.', 'error');
            }

            checkWinCondition();
        }

        // Process command from user input
        window.processCommand = function() {
            const input = document.getElementById('input');
            const command = input.value.trim();
            input.value = '';

            if (!command) return;

            printLine('> ' + command, 'prompt');

            // Allow load/list commands even when dead or game over
            const verb = command.split(' ')[0].toLowerCase();
            const allowedWhenDead = ['cargar', 'load', 'partidas', 'saves'];

            if ((gameState.gameOver || gameState.gameWon || gameState.player.dead) && !allowedWhenDead.includes(verb)) {
                printLine('El juego ha terminado. Use "cargar [nombre]" para cargar una partida guardada.');
                return;
            }

            executeCommand(command);

            // Track state-changing commands AFTER execution
            if (shouldSaveCommand(command)) {
                console.log('[HISTORY] Adding command to history:', command);
                gameState.commandHistory.push(command);
                console.log('[HISTORY] Total commands in history:', gameState.commandHistory.length);
            }

            // If in touch mode, reset to verb selection after command
            if (touchModeEnabled) {
                resetTouchMode();
            }
        }

        // Check win condition
        function checkWinCondition() {
            // Win condition: destroy all 4 centers and the Troll
            const centersToDestroy = ['Centro del cerebro', 'Centro del corazon', 'Centro del estomago', 'Centro de los pulmones'];

            let allCentersDestroyed = true;
            for (let center of centersToDestroy) {
                let found = false;
                for (let room of gameState.rooms) {
                    if (room.get(center)) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    allCentersDestroyed = false;
                    break;
                }
            }

            // Check if Troll in room 11 is dead
            let trollDead = true;
            const bathRoom = gameState.rooms[11];
            const troll = bathRoom.get('Troll');
            if (troll && !troll.dead) {
                trollDead = false;
            }

            if (allCentersDestroyed && trollDead) {
                gameState.gameWon = true;
                printLine('', '');
                printLine('Â¡Â¡Â¡VICTORIA!!!', 'success');
                printLine('Usted ha vencido a la Bestia.', 'success');
                printLine('Parece ser una persona persistente y eso es un mÃ©rito muy grande.');
                printLine('La persistencia es indispensable para los que luchan por el bien,');
                printLine('sobre todo porque los que luchan por el mal son muy persistentes tambiÃ©n.');
                printLine('Veremos si en la prÃ³xima versiÃ³n de La Fortaleza tiene igual suerte.');
                printLine('', '');
                printLine('                                             Un servidor:', 'system');
                printLine('                                             M. Cepero', 'system');
            }
        }

        // Handle keyboard events for input
        const inputElement = document.getElementById('input');

        // Handle key input and autocomplete
        inputElement.addEventListener('input', function(e) {
            updateAutocompleteDisplay(this);
        });

        inputElement.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                acceptSuggestion();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                cycleSuggestion(1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                cycleSuggestion(-1);
            } else if (e.key === 'Escape') {
                // Clear autocomplete
                const existing = this.parentElement.querySelector('.autocomplete-suggestion');
                if (existing) existing.remove();
                autocompleteState.suggestions = [];
                autocompleteState.currentIndex = -1;
            }
        });

        inputElement.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Clear autocomplete on enter
                const existing = this.parentElement.querySelector('.autocomplete-suggestion');
                if (existing) existing.remove();
                autocompleteState.suggestions = [];
                processCommand();
            }
        });

        // ==================== TOUCH MODE ====================

        let touchModeEnabled = false;
        let touchModeState = {
            commandParts: [],
            currentStage: 'verb'
        };

        window.toggleTouchMode = function() {
            touchModeEnabled = !touchModeEnabled;
            const btn = document.getElementById('touch-mode-btn');
            const input = document.getElementById('input');
            const dropdown = document.getElementById('dropdown-container');

            if (touchModeEnabled) {
                btn.classList.add('active');
                input.classList.add('touch-mode');
                input.readOnly = true;
                input.placeholder = 'Modo tÃ¡ctil activado - usa los botones';
                dropdown.classList.add('active');
                showVerbOptions();
            } else {
                btn.classList.remove('active');
                input.classList.remove('touch-mode');
                input.readOnly = false;
                input.placeholder = 'Escribe tu comando aquÃ­...';
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
                touchModeState = { commandParts: [], currentStage: 'verb' };
                input.value = '';
            }
        };

        function showVerbOptions() {
            const verbs = [
                { display: 'IR', value: 'ir' },
                { display: 'TOMAR', value: 'tomar' },
                { display: 'DEJAR', value: 'dejar' },
                { display: 'MIRAR', value: 'mirar' },
                { display: 'VER', value: 'ver' },
                { display: 'INVENTARIO', value: 'inventario' },
                { display: 'ABRIR', value: 'abrir' },
                { display: 'ROMPER', value: 'romper' },
                { display: 'MATAR', value: 'matar' },
                { display: 'DAR', value: 'dar' },
                { display: 'HABLAR', value: 'hablar' },
                { display: 'PESAR', value: 'pesar' },
                { display: 'GUARDAR', value: 'guardar' },
                { display: 'CARGAR', value: 'cargar' },
                { display: 'PARTIDAS', value: 'partidas' },
                { display: 'BORRAR', value: 'borrar' }
            ];

            renderDropdown('Selecciona AcciÃ³n', verbs, (verb) => {
                touchModeState.commandParts = [verb];
                touchModeState.currentStage = 'object';
                document.getElementById('input').value = verb;

                // Commands that don't need objects
                const standalone = ['mirar', 'inventario', 'partidas'];
                if (standalone.includes(verb)) {
                    executeTouchModeCommand();
                } else if ((verb === 'dar' || verb === 'dejar') && gameState.player.bag.items.length === 0) {
                    // Can't give/drop if inventory is empty
                    toggleTouchMode();
                    printLine('No tienes nada para ' + (verb === 'dar' ? 'dar' : 'dejar') + '.', 'error');
                } else {
                    showObjectOptions(verb);
                }
            }, false, 'verb-options'); // No cancel button on first screen, use verb-options class
        }

        function showObjectOptions(verb) {
            const player = gameState.player;
            const room = player.curr;
            let options = [];

            // Build options based on verb
            if (verb === 'ir' || verb === 'atravesar') {
                // Show all links in current room
                room.items.forEach(item => {
                    if (item instanceof Linking || item instanceof RiddleLink ||
                        item instanceof OpenLink || item instanceof DangerLink ||
                        item instanceof DangerLink2) {
                        options.push({ display: item.name.toUpperCase(), value: item.name });
                    }
                });
            } else if (verb === 'tomar') {
                // Show takeable items in room
                room.items.forEach(item => {
                    if (item.mass < 999 && !(item instanceof Linking)) {
                        options.push({ display: item.name.toUpperCase(), value: item.name });
                    }
                });
            } else if (verb === 'dejar') {
                // Show inventory items
                player.bag.items.forEach(item => {
                    options.push({ display: item.name.toUpperCase(), value: item.name });
                });
                // Add "todo" option
                options.unshift({ display: 'TODO', value: 'todo' });
            } else if (verb === 'ver' || verb === 'pesar') {
                // Show all items in room and inventory
                room.items.forEach(item => {
                    options.push({ display: item.name.toUpperCase() + ' (aquÃ­)', value: item.name });
                });
                player.bag.items.forEach(item => {
                    options.push({ display: item.name.toUpperCase() + ' (tuyo)', value: item.name });
                });
            } else if (verb === 'abrir' || verb === 'romper' || verb === 'matar' || verb === 'hablar') {
                // Show all items in room
                room.items.forEach(item => {
                    options.push({ display: item.name.toUpperCase(), value: item.name });
                });
            } else if (verb === 'dar') {
                // Show inventory items
                player.bag.items.forEach(item => {
                    options.push({ display: item.name.toUpperCase(), value: item.name });
                });
            } else if (verb === 'guardar' || verb === 'cargar' || verb === 'borrar') {
                // Show saved games
                const saves = listSaves();
                saves.forEach(save => {
                    options.push({ display: save.name.toUpperCase(), value: save.name });
                });
                // Add option to type custom name for save
                if (verb === 'guardar') {
                    options.push({ display: '+ NUEVO NOMBRE', value: '__custom__' });
                }
            }

            if (options.length === 0) {
                options.push({ display: '(Nada disponible)', value: null });
            }

            renderDropdown('Selecciona Objeto', options, (object) => {
                if (object === '__custom__') {
                    // Show keyboard for custom save name
                    touchModeState.currentStage = 'keyboard';
                    document.getElementById('input').value = verb + ' ';
                    showKeyboard();
                    return;
                }
                if (object === null) return;

                touchModeState.commandParts.push(object);
                document.getElementById('input').value = touchModeState.commandParts.join(' ');

                // Check if command needs additional parameters
                if (verb === 'abrir') {
                    // Abrir: ask if with or without password
                    touchModeState.currentStage = 'abrir-choice';
                    showAbrirChoice();
                } else if (verb === 'romper' || verb === 'matar') {
                    touchModeState.currentStage = 'with';
                    showWithOptions(verb);
                } else if (verb === 'dar') {
                    touchModeState.currentStage = 'to';
                    showToOptions();
                } else {
                    executeTouchModeCommand();
                }
            }, true, 'object-options'); // Use object-options class for wider buttons
        }

        function showWithOptions(verb) {
            const player = gameState.player;
            const room = player.curr;
            let options = [];

            // Show inventory items that could be weapons/tools
            player.bag.items.forEach(item => {
                options.push({ display: item.name.toUpperCase() + ' (tuyo)', value: item.name });
            });

            // Also show items in room
            room.items.forEach(item => {
                if (item.mass < 999 && !(item instanceof Linking)) {
                    options.push({ display: item.name.toUpperCase() + ' (aquÃ­)', value: item.name });
                }
            });

            // Add "sin nada" option for trying without tool
            options.push({ display: '(Sin objeto)', value: '' });

            renderDropdown('Â¿Con quÃ©?', options, (tool) => {
                if (tool) {
                    touchModeState.commandParts.push('con', tool);
                }
                document.getElementById('input').value = touchModeState.commandParts.join(' ');
                executeTouchModeCommand();
            }, true, 'object-options');
        }

        function showToOptions() {
            const room = gameState.player.curr;
            let options = [];

            // Show living things in room
            room.items.forEach(item => {
                if (item instanceof LivingThing) {
                    options.push({ display: item.name.toUpperCase(), value: item.name });
                }
            });

            if (options.length === 0) {
                options.push({ display: '(Nadie aquÃ­)', value: null });
            }

            renderDropdown('Â¿A quiÃ©n?', options, (recipient) => {
                if (recipient === null) return;
                touchModeState.commandParts.push('a', recipient);
                document.getElementById('input').value = touchModeState.commandParts.join(' ');
                executeTouchModeCommand();
            }, true, 'object-options');
        }

        function showAbrirChoice() {
            const options = [
                { display: 'SIN DECIR NADA', value: 'without' },
                { display: 'CON PALABRAS', value: 'with' }
            ];

            renderDropdown('Â¿CÃ³mo abrir?', options, (choice) => {
                if (choice === 'without') {
                    // Execute abrir without password
                    executeTouchModeCommand();
                } else {
                    // Show keyboard for password entry
                    touchModeState.currentStage = 'keyboard';
                    touchModeState.commandParts.push('con');
                    document.getElementById('input').value = touchModeState.commandParts.join(' ') + ' ';
                    showKeyboard();
                }
            });
        }

        function showKeyboard() {
            const container = document.getElementById('dropdown-container');
            container.innerHTML = '';

            const keyboard = document.createElement('div');
            keyboard.className = 'on-screen-keyboard';

            // Letter rows (keyboard layout)
            // Row 1: Q-P + Backspace (right)
            // Row 2: A-L + EJECUTAR (right)
            // Row 3: Z-M + Space (in letters) + CANCELAR (right)
            const rows = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', 'âŒ«'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ' ']
            ];

            rows.forEach((row, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';

                // Left section: letter keys
                const lettersDiv = document.createElement('div');
                lettersDiv.className = 'keyboard-letters';

                row.forEach(key => {
                    const btn = document.createElement('button');
                    btn.className = 'keyboard-key';

                    if (key === 'âŒ«') {
                        btn.textContent = key;
                        btn.onclick = () => {
                            document.getElementById('input').value = document.getElementById('input').value.slice(0, -1);
                        };
                    } else if (key === ' ') {
                        btn.textContent = 'âŽµ';
                        btn.className = 'keyboard-key keyboard-space-letter';
                        btn.onclick = () => {
                            document.getElementById('input').value += ' ';
                        };
                    } else {
                        btn.textContent = key;
                        btn.onclick = () => {
                            document.getElementById('input').value += key.toLowerCase();
                        };
                    }
                    lettersDiv.appendChild(btn);
                });

                rowDiv.appendChild(lettersDiv);

                // Right section: EJECUTAR and CANCELAR buttons
                if (rowIndex === 1) {
                    // Row 2: EJECUTAR button
                    const ejecutarBtn = document.createElement('button');
                    ejecutarBtn.className = 'keyboard-key keyboard-action';
                    ejecutarBtn.textContent = 'EJECUTAR';
                    ejecutarBtn.onclick = () => {
                        processCommand();
                    };
                    rowDiv.appendChild(ejecutarBtn);
                } else if (rowIndex === 2) {
                    // Row 3: CANCELAR button
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'keyboard-key keyboard-action keyboard-cancel';
                    cancelBtn.textContent = 'CANCELAR';
                    cancelBtn.onclick = () => {
                        resetTouchMode();
                    };
                    rowDiv.appendChild(cancelBtn);
                }

                keyboard.appendChild(rowDiv);
            });

            container.appendChild(keyboard);
        }

        function renderDropdown(title, options, onSelect, showCancel = true, optionsClass = '') {
            const container = document.getElementById('dropdown-container');

            // Clear existing content - replace instead of append
            container.innerHTML = '';

            const stage = document.createElement('div');
            stage.className = 'dropdown-stage';

            const titleEl = document.createElement('div');
            titleEl.className = 'dropdown-stage-title';
            titleEl.textContent = title;
            stage.appendChild(titleEl);

            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'dropdown-options' + (optionsClass ? ' ' + optionsClass : '');

            options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'dropdown-option';
                btn.textContent = option.display;
                btn.onclick = () => {
                    onSelect(option.value);
                };
                optionsContainer.appendChild(btn);
            });

            // Add CANCEL button for secondary screens
            if (showCancel) {
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'dropdown-option dropdown-cancel';
                cancelBtn.textContent = 'âœ• CANCELAR';
                cancelBtn.onclick = () => {
                    resetTouchMode();
                };
                optionsContainer.appendChild(cancelBtn);
            }

            stage.appendChild(optionsContainer);
            container.appendChild(stage);
        }

        function resetTouchMode() {
            // Reset state and show verb options
            touchModeState = { commandParts: [], currentStage: 'verb' };
            document.getElementById('input').value = '';
            showVerbOptions();
        }

        function executeTouchModeCommand() {
            const command = touchModeState.commandParts.join(' ');
            document.getElementById('input').value = command;

            // Execute the command (processCommand will handle the reset)
            processCommand();
        }

        // Fullscreen toggle
        window.toggleFullscreen = function() {
            const elem = document.documentElement;
            const btn = document.getElementById('fullscreen-btn');

            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { // IE11
                    elem.msRequestFullscreen();
                }
                btn.textContent = 'â›¶'; // Exit fullscreen icon
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE11
                    document.msExitFullscreen();
                }
                btn.textContent = 'â›¶'; // Fullscreen icon
            }
        }

        // Update button when fullscreen changes via ESC key
        document.addEventListener('fullscreenchange', function() {
            const btn = document.getElementById('fullscreen-btn');
            btn.textContent = document.fullscreenElement ? 'â›¶' : 'â›¶';
        });

        // Start game
        initGame();

        // Set focus to input
        document.getElementById('input').focus();
    </script>
</body>
</html>
